---
title: "Branch-Level Regressions: ZIP Competitor Dynamics"
author: "Generated Output"
format:
  html:
    self-contained: true
    code-overflow: scroll
    toc: true
execute:
  warning: false
  echo: true
---

Minimal version of `results_competitor_close_open_v4.0.qmd` that analyzes branch-level
deposit growth as a function of competitor closures/openings at the ZIP level.

# Setup

```{r}
#| warning: false
#| messages: false

rm(list=ls())
library(data.table)
library(fixest)
library(DescTools)
library(dplyr)

# Load summary stats function
source('https://raw.githubusercontent.com/dratnadiwakara/r-utilities/refs/heads/main/summary_stat_tables.R')

# Load branch ZIP panel
panel_path <- "C:/OneDrive/data/branch_zip_panel.rds"
dt <- readRDS(panel_path)
setDT(dt)

# Sample restrictions: branches with no own closures/openings
dt_3yr <- dt[own_closures_zip == 0 & 
             own_openings_zip == 0 & 
             !is.na(dep_gr_3yr) &
             dep_gr_3yr < 1]


# Winsorize for 3-year sample
dt_3yr[, dep_gr_3yr := Winsorize(dep_gr_3yr, 
                                                val = quantile(dep_gr_3yr, 
                                                               probs = c(0.01, 0.99), na.rm = TRUE))]



```

# Summary Statistics

## Reviews Data: Descriptive Analysis

```{r}
#| warning: false
#| messages: false

library(ggplot2)

# Load raw reviews (review-level data)
reviews_raw <- fread("C:/OneDrive/data/CH_app_reviews_data.csv")
setDT(reviews_raw)

# Load FDIC data for bank characteristics
fdic_all <- readRDS("C:/OneDrive/data/fdic_sod_2000_2025_simple.rds")
setDT(fdic_all)
fdic_all <- fdic_all[, .(CERT, ASSET, YEAR)]
fdic_all <- unique(fdic_all)

# Merge reviews with FDIC to get bank sizes
reviews_raw <- merge(reviews_raw, fdic_all, 
                     by.x = c("FDIC_certificate_id", "review_year"), 
                     by.y = c("CERT", "YEAR"), 
                     all.x = TRUE)

# Create size categories
reviews_raw[, size_category := fifelse(ASSET >= 10000000, "Large (>$10B)",
                                       fifelse(ASSET >= 1000000, "Medium ($1B-$10B)",
                                              fifelse(ASSET > 0, "Small (<$1B)", NA_character_)))]

# Aggregate to bank-year level
reviews_agg <- reviews_raw[, .(
  mean_app_rating = mean(rating, na.rm = TRUE),
  total_reviews = sum(reviews_count, na.rm = TRUE),
  n_review_obs = .N
), by = .(FDIC_certificate_id, review_year, ASSET, size_category)]

setnames(reviews_agg, c("FDIC_certificate_id", "review_year"), c("CERT", "YEAR"))

# Flag banks with vs without reviews
banks_with_reviews <- unique(reviews_agg$CERT)
fdic_all[, has_review := fifelse(CERT %in% banks_with_reviews, 1L, 0L)]

# Also keep reviews_with_size for downstream analyses (using reviews_agg)
reviews_with_size <- reviews_agg

```

### Overview: Review-Level Data

```{r}
#| warning: false
#| messages: false

cat("Total reviews in dataset:", nrow(reviews_raw), "\n")
cat("Unique banks with reviews:", uniqueN(reviews_raw$FDIC_certificate_id), "\n")
cat("Review period:", min(reviews_raw$review_year), "to", max(reviews_raw$review_year), "\n\n")

cat("Mean rating (all reviews):", round(mean(reviews_raw$rating, na.rm = TRUE), 3), "\n")
cat("SD rating:", round(sd(reviews_raw$rating, na.rm = TRUE), 3), "\n")
cat("Median reviews per bank-year:", median(reviews_agg$total_reviews, na.rm = TRUE), "\n")

```

### Review Counts and Frequency by Bank Size

```{r}
#| warning: false
#| messages: false

# Analysis by size category for 2019
reviews_by_size_2019 <- reviews_agg[YEAR == 2019 & !is.na(size_category), .(
  n_banks = .N,
  mean_reviews = mean(total_reviews, na.rm = TRUE),
  median_reviews = median(total_reviews, na.rm = TRUE),
  total_reviews = sum(total_reviews, na.rm = TRUE),
  mean_rating = mean(mean_app_rating, na.rm = TRUE)
), by = size_category]

print("Review Activity by Bank Size (2019):")
print(reviews_by_size_2019)

# Plot: Total reviews by size category over time
reviews_by_size_year <- reviews_agg[!is.na(size_category), .(
  total_reviews = sum(total_reviews, na.rm = TRUE),
  n_banks = .N
), by = .(review_year = YEAR, size_category)]

ggplot(reviews_by_size_year, aes(x = review_year, y = total_reviews, fill = size_category)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Total App Reviews by Bank Size Over Time",
       x = "Year", y = "Number of Reviews", fill = "Bank Size") +
  theme_minimal()

```

### Rating Variance by Bank Size

```{r}
#| warning: false
#| messages: false

# Within-bank rating variance (using individual reviews)
rating_variance <- reviews_raw[!is.na(size_category), .(
  mean_rating = mean(rating, na.rm = TRUE),
  sd_rating = sd(rating, na.rm = TRUE),
  n_reviews = .N
), by = .(FDIC_certificate_id, review_year, size_category)]

# Aggregate variance by size category (2019)
variance_by_size <- rating_variance[review_year == 2019 & n_reviews >= 5, .(
  mean_sd = mean(sd_rating, na.rm = TRUE),
  median_sd = median(sd_rating, na.rm = TRUE),
  n_banks = .N
), by = size_category]

print("Rating Variance by Bank Size (2019, banks with 5+ reviews):")
print(variance_by_size)

# Plot: Distribution of within-bank rating SD by size
ggplot(rating_variance[review_year == 2019 & n_reviews >= 5], 
       aes(x = size_category, y = sd_rating)) +
  geom_boxplot() +
  labs(title = "Within-Bank Rating Variance by Size (2019)",
       subtitle = "Banks with 5+ reviews only",
       x = "Bank Size", y = "SD of Ratings") +
  theme_minimal()

```

### Coverage: Banks with vs without App Reviews

```{r}
#| warning: false
#| messages: false

# By year: count and asset share
coverage_by_year <- fdic_all[, .(
  n_banks = uniqueN(CERT),
  n_with_review = uniqueN(CERT[has_review == 1]),
  total_assets = sum(ASSET, na.rm = TRUE),
  assets_with_review = sum(ASSET[has_review == 1], na.rm = TRUE)
), by = YEAR]

coverage_by_year[, pct_banks_with_review := 100 * n_with_review / n_banks]
coverage_by_year[, pct_assets_with_review := 100 * assets_with_review / total_assets]

# Plot: Coverage over time
ggplot(coverage_by_year[YEAR >= 2010], aes(x = YEAR)) +
  geom_line(aes(y = pct_banks_with_review), color = "blue") +
  geom_line(aes(y = pct_assets_with_review), color = "red", linetype = "dashed") +
  labs(title = "App Review Coverage (Blue: % Banks, Red: % Assets)",
       y = "Percent", x = "Year") +
  theme_minimal()

```

### Bank Size: With vs Without Reviews

```{r}
#| warning: false
#| messages: false

# Compare asset distribution
size_comparison <- fdic_all[YEAR == 2019, .(
  mean_asset = mean(ASSET, na.rm = TRUE),
  median_asset = median(ASSET, na.rm = TRUE),
  n = .N
), by = has_review]

print(size_comparison)

# Plot: Asset distribution
fdic_all_2019 <- fdic_all[YEAR == 2019 & ASSET > 0]
ggplot(fdic_all_2019, aes(x = log(ASSET), fill = factor(has_review))) +
  geom_density(alpha = 0.5) +
  labs(title = "Bank Size Distribution (2019)",
       x = "log(Assets)", fill = "Has Review") +
  theme_minimal()

```

### App Quality: High vs Low Ratings Over Time

```{r}
#| warning: false
#| messages: false

# Create app quality bins
reviews_with_size[, app_quality := fifelse(mean_app_rating >= 4, "High (4+)",
                                           fifelse(mean_app_rating >= 3, "Medium (3-4)",
                                                  "Low (<3)"))]

# Count by year and quality
quality_by_year <- reviews_with_size[, .(
  n_banks = uniqueN(CERT),
  mean_asset = mean(ASSET, na.rm = TRUE)
), by = .(YEAR, app_quality)]

# Plot: Number of banks by app quality over time
ggplot(quality_by_year, aes(x = YEAR, y = n_banks, color = app_quality)) +
  geom_line() +
  labs(title = "Banks by App Quality Over Time",
       y = "Number of Banks", color = "App Quality") +
  theme_minimal()

```

### App Quality vs Bank Size

```{r}
#| warning: false
#| messages: false

# 2019 comparison
reviews_2019 <- reviews_with_size[YEAR == 2019]

# Mean assets by quality
asset_by_quality <- reviews_2019[, .(
  mean_asset = mean(ASSET, na.rm = TRUE),
  median_asset = median(ASSET, na.rm = TRUE),
  n = .N
), by = app_quality]

print(asset_by_quality)

# Plot: Asset distribution by app quality
ggplot(reviews_2019[ASSET > 0], aes(x = app_quality, y = log(ASSET))) +
  geom_boxplot() +
  labs(title = "Bank Size by App Quality (2019)",
       x = "App Quality", y = "log(Assets)") +
  theme_minimal()

```

### Correlation: Bank Size vs App Rating

```{r}
#| warning: false
#| messages: false

# Correlation analysis for 2019
reviews_2019_clean <- reviews_2019[!is.na(ASSET) & ASSET > 0 & !is.na(mean_app_rating)]
reviews_2019_clean[, log_asset := log(ASSET)]

# Compute correlations
cor_log <- cor(reviews_2019_clean$log_asset, reviews_2019_clean$mean_app_rating, 
               use = "complete.obs")
cor_raw <- cor(reviews_2019_clean$ASSET, reviews_2019_clean$mean_app_rating, 
               use = "complete.obs")

cat("Correlation between log(Assets) and App Rating (2019):", round(cor_log, 3), "\n")
cat("Correlation between Assets and App Rating (2019):", round(cor_raw, 3), "\n\n")

# Simple linear regression
lm_result <- lm(mean_app_rating ~ log_asset, data = reviews_2019_clean)
cat("Regression: mean_app_rating ~ log(Assets)\n")
cat("  Coefficient on log(Assets):", round(coef(lm_result)[2], 4), "\n")
cat("  t-statistic:", round(summary(lm_result)$coefficients[2, 3], 2), "\n")
cat("  R-squared:", round(summary(lm_result)$r.squared, 4), "\n\n")

# Raw scatterplot (sample if too many points)
if (nrow(reviews_2019_clean) > 1000) {
  sample_size <- 1000
  plot_data <- reviews_2019_clean[sample(.N, sample_size)]
  plot_title <- paste0("Bank Size vs App Rating (2019, Random Sample of ", sample_size, ")")
} else {
  plot_data <- reviews_2019_clean
  plot_title <- "Bank Size vs App Rating (2019, All Banks)"
}

ggplot(plot_data, aes(x = log_asset, y = mean_app_rating)) +
  geom_point(alpha = 0.4) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  labs(title = plot_title,
       x = "log(Assets)", y = "Mean App Rating") +
  theme_minimal()

# Binned scatterplot: group log(Assets) into bins and plot mean rating per bin
reviews_2019_clean[, asset_bin := cut(log_asset, breaks = 20, labels = FALSE)]
binned_data <- reviews_2019_clean[, .(
  mean_log_asset = mean(log_asset),
  mean_rating = mean(mean_app_rating),
  median_rating = median(mean_app_rating),
  sd_rating = sd(mean_app_rating),
  n = .N
), by = asset_bin]

ggplot(binned_data, aes(x = mean_log_asset, y = mean_rating)) +
  geom_point(aes(size = n)) +
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  geom_errorbar(aes(ymin = mean_rating - sd_rating/sqrt(n), 
                    ymax = mean_rating + sd_rating/sqrt(n)), 
                width = 0.1, alpha = 0.5) +
  labs(title = "Binned Scatter: Bank Size vs App Rating (2019)",
       subtitle = "20 equal-sized bins, error bars show +/- SE",
       x = "log(Assets) Bin Average", y = "Mean App Rating", size = "N Banks") +
  theme_minimal()

```

### Review Penetration: What Share of Banks Have Apps?

```{r}
#| warning: false
#| messages: false

# For each size category, what fraction of banks have reviews?
# Need to merge all banks with review flags
fdic_all[, size_category := fifelse(ASSET >= 10000000, "Large (>$10B)",
                                    fifelse(ASSET >= 1000000, "Medium ($1B-$10B)",
                                           fifelse(ASSET > 0, "Small (<$1B)", NA_character_)))]

penetration_2019 <- fdic_all[YEAR == 2019 & !is.na(size_category), .(
  n_banks = .N,
  n_with_app = sum(has_review),
  pct_with_app = 100 * mean(has_review)
), by = size_category]

print("App Penetration by Bank Size (2019):")
print(penetration_2019)

# Over time
penetration_time <- fdic_all[YEAR >= 2010 & !is.na(size_category), .(
  pct_with_app = 100 * mean(has_review)
), by = .(YEAR, size_category)]

ggplot(penetration_time, aes(x = YEAR, y = pct_with_app, color = size_category)) +
  geom_line() +
  labs(title = "App Penetration Rate by Bank Size Over Time",
       x = "Year", y = "% of Banks with App Reviews", color = "Bank Size") +
  theme_minimal()

```

### Size and Rating Over Time

```{r}
#| warning: false
#| messages: false

# Mean rating by size category over time
rating_by_size_year <- reviews_with_size[!is.na(mean_app_rating) & !is.na(size_category), .(
  mean_rating = mean(mean_app_rating, na.rm = TRUE),
  n_banks = .N
), by = .(YEAR, size_category)]

# Plot: Mean rating by size over time
ggplot(rating_by_size_year, aes(x = YEAR, y = mean_rating, color = size_category)) +
  geom_line() +
  geom_point() +
  labs(title = "Mean App Rating by Bank Size Over Time",
       x = "Year", y = "Mean App Rating", color = "Size Category") +
  theme_minimal()

```

### Distribution of Ratings by Size (2019)

```{r}
#| warning: false
#| messages: false

# Histogram of ratings by size category
ggplot(reviews_2019_clean, aes(x = mean_app_rating, fill = size_category)) +
  geom_histogram(bins = 30, alpha = 0.6, position = "identity") +
  labs(title = "Distribution of App Ratings by Bank Size (2019)",
       x = "Mean App Rating", fill = "Size Category") +
  theme_minimal()

```


## Sample Overview

```{r}
#| warning: false
#| messages: false

cat("3-Year Growth Sample:\n")
cat("  Observations:", nrow(dt_3yr), "\n")
cat("  Unique branches:", uniqueN(dt_3yr$UNINUMBR), "\n")
cat("  Unique ZIPs:", uniqueN(dt_3yr$zip), "\n")
cat("  Years:", min(dt_3yr$YEAR), "to", max(dt_3yr$YEAR), "\n\n")
cat("  Mean dep_gr_3yr:", round(mean(dt_3yr$dep_gr_3yr, na.rm = TRUE), 4), "\n")
cat("  Mean competitor_close_dep_share_prev:", 
    round(mean(dt_3yr$competitor_close_dep_share_prev, na.rm = TRUE), 4), "\n")
```

## Summary Stats for 2019 (Full Sample)

```{r}
#| warning: false
#| messages: false

# -----------------------------------------------------------------------------
# SUMMARY STATISTICS
# -----------------------------------------------------------------------------
# Purpose: Generate summary stats for all variables used in the regression analysis.
# -----------------------------------------------------------------------------

vars <- c(
  # --- Dependent Variable ---
  "dep_gr_3yr",                       # 3-year branch deposit growth
  
  # --- Shock Variables (Grouped by App Quality) ---
  "competitor_close_dep_share_prev",  # Total competitor closure share
  "competitor_close_share_no_app",    # No app closures (bin 0)
  "competitor_close_share_low_app",   # Low app closures (bins 1-2)
  "competitor_close_share_high_app",  # High app closures (bins 3-4)
  
  # --- Branch Control ---
  "DEPSUMBR",                         # Branch deposits
  
  # --- Demographics ---
  "sophisticated",                    # Binary: sophisticated ZIP
  "above_median_age",                 # Binary: above median age
  "above_median_income"               # Binary: above median income
)

# Table 1: Summary Stats for 2019 (Full Sample)
temp <- summary_stats_function(dt_3yr[YEAR == 2019], vars)
md_table(temp)

```

## Summary Stats for 2019 (Conditioned on Non-Zero Competitor Closure)

```{r}
#| warning: false
#| messages: false

# Table 2: Summary Stats for 2019 (Conditioned on Non-Zero Competitor Closure)
# Shows stats specifically for branches affected by competitor closures
temp <- summary_stats_function(dt_3yr[YEAR == 2019 & competitor_close_dep_share_prev > 0], vars)
md_table(temp)

```

# Analysis

## Define Fixed Effects and Formulas

```{r}
#| warning: false
#| messages: false

setFixest_fml(
  ..fixef_br_ctyyr = ~ UNINUMBR + county_yr,
  ..fixef_ctyyr_bnkyr = ~ county_yr + bank_yr,
  ..fixef_br_ctyyr_bnkyr = ~ UNINUMBR + county_yr + bank_yr,
  ..fml_baseline_amt = ~ competitor_close_dep_share_prev + log1p(DEPSUMBR),
  ..fml_interact = ~ competitor_close_dep_share_prev*sophisticated + competitor_close_dep_share_prev*above_median_age + competitor_close_dep_share_prev*above_median_income + log1p(DEPSUMBR)
)

# Variable labels
dict <- c(
  dep_gr_3yr = "Dep growth (t to t+3)",
  dep_gr_1yr = "Dep growth (t to t+1)",
  competitor_closures_rate = "Competitor closure rate (ZIP)",
  competitor_close_dep_share_prev = "Competitor closure dep share (t-1)",
  "log1p(DEPSUMBR)" = "log(Deposits)"
)

setFixest_etable(
  dict = dict,
  se.below = TRUE
)

```

## Baseline Regressions

Test whether competitor closures lead to deposit inflows at surviving branches.

```{r}
#| warning: false
#| messages: false

r <- list()

# Model 1: Branch FE + County-Year FE (deposit share measure)
r[[1]] <- feols(dep_gr_3yr ~ ..fml_baseline_amt | ..fixef_br_ctyyr, 
                data = dt_3yr)

# Model 2: County-Year FE + Bank-Year FE (deposit share)
r[[2]] <- feols(dep_gr_3yr ~ ..fml_baseline_amt | ..fixef_ctyyr_bnkyr, 
                data = dt_3yr, 
                vcov = ~ UNINUMBR)

# Model 3: All three FE (deposit share)
r[[3]] <- feols(dep_gr_3yr ~ ..fml_baseline_amt | ..fixef_br_ctyyr_bnkyr, 
                data = dt_3yr)


etable(r, 
       signif.code = c("***" = 0.01, "**" = 0.05, "*" = 0.10),
       headers = c("Br+Cty-Yr", "Cty-Yr+Bnk-Yr", "All FE"))

```

## Time Heterogeneity

Split by time periods to test if effects vary across crisis/recovery/modern eras.

```{r}
#| warning: false
#| messages: false

r <- list()

r[[1]] <-  feols(dep_gr_3yr ~ ..fml_baseline_amt | ..fixef_ctyyr_bnkyr, 
                data = dt_3yr[YEAR %in% 2001:2011])

r[[2]] <- feols(dep_gr_3yr ~ ..fml_baseline_amt | ..fixef_ctyyr_bnkyr, 
                data = dt_3yr[YEAR %in% 2012:2021])

etable(r, 
       signif.code = c("***" = 0.01, "**" = 0.05, "*" = 0.10),
       headers = c("2001-2011", "2012-2021"))

```
## Time Heterogeneity-Interaction


```{r}
#| warning: false
#| messages: false

r <- list()

r[[1]] <-  feols(dep_gr_3yr ~ ..fml_interact  | ..fixef_ctyyr_bnkyr, 
                data = dt_3yr[YEAR %in% 2001:2011], 
                vcov = ~ UNINUMBR)

r[[2]] <- feols(dep_gr_3yr ~ ..fml_interact  | ..fixef_ctyyr_bnkyr, 
                data = dt_3yr[YEAR %in% 2012:2021], 
                vcov = ~ UNINUMBR)

etable(r, 
       signif.code = c("***" = 0.01, "**" = 0.05, "*" = 0.10),
       headers = c("2001-2011", "2012-2021"))

```

## App Quality of Competitor Closers

Test whether closures by high-app vs low-app competitors have different effects.
The three app quality groups have comparable scales for easier interpretation.

```{r}
#| warning: false
#| messages: false

r <- list()

# Model 1: Baseline with total closure share
r[[1]] <- feols(dep_gr_3yr ~ competitor_close_dep_share_prev + log1p(DEPSUMBR) | UNINUMBR + county_yr + bank_yr, 
                data = dt_3yr)

# Model 2: Grouped - high app (bins 3-4) vs low app (bins 1-2) vs no app (bin 0)
r[[2]] <- feols(dep_gr_3yr ~ competitor_close_share_high_app + 
                            competitor_close_share_low_app + 
                            competitor_close_share_no_app +
                            log1p(DEPSUMBR) | UNINUMBR + county_yr + bank_yr, 
                data = dt_3yr)

etable(r, 
       signif.code = c("***" = 0.01, "**" = 0.05, "*" = 0.10),
       headers = c("Total", "By App Group"))

```

## App Quality: Time Heterogeneity

Test whether app quality effects differ across time periods.

```{r}
#| warning: false
#| messages: false

r <- list()

# Pre-2012: Split by app quality
r[[1]] <- feols(dep_gr_3yr ~ competitor_close_share_high_app + 
                            competitor_close_share_low_app + 
                            competitor_close_share_no_app +
                            log1p(DEPSUMBR) | UNINUMBR + county_yr + bank_yr, 
                data = dt_3yr[YEAR %in% 2001:2011])

# Post-2012: Split by app quality
r[[2]] <- feols(dep_gr_3yr ~ competitor_close_share_high_app + 
                            competitor_close_share_low_app + 
                            competitor_close_share_no_app +
                            log1p(DEPSUMBR) | UNINUMBR + county_yr + bank_yr, 
                data = dt_3yr[YEAR %in% 2012:2021])

etable(r, 
       signif.code = c("***" = 0.01, "**" = 0.05, "*" = 0.10),
       headers = c("Pre-2012", "Post-2012"))

```

## App Quality: Demographic Interactions

Test whether effects vary by ZIP demographics (sophistication, age, income).

```{r}
#| warning: false
#| messages: false

r <- list()

# Model 1: Interaction with sophisticated ZIP
r[[1]] <- feols(dep_gr_3yr ~ (competitor_close_share_high_app + 
                              competitor_close_share_low_app + 
                              competitor_close_share_no_app) * sophisticated +
                            log1p(DEPSUMBR) | UNINUMBR + county_yr + bank_yr, 
                data = dt_3yr,
                vcov = ~ UNINUMBR)

# Model 2: Interaction with above median age
r[[2]] <- feols(dep_gr_3yr ~ (competitor_close_share_high_app + 
                              competitor_close_share_low_app + 
                              competitor_close_share_no_app) * above_median_age +
                            log1p(DEPSUMBR) | UNINUMBR + county_yr + bank_yr, 
                data = dt_3yr,
                vcov = ~ UNINUMBR)

# Model 3: Interaction with above median income
r[[3]] <- feols(dep_gr_3yr ~ (competitor_close_share_high_app + 
                              competitor_close_share_low_app + 
                              competitor_close_share_no_app) * above_median_income +
                            log1p(DEPSUMBR) | UNINUMBR + county_yr + bank_yr, 
                data = dt_3yr,
                vcov = ~ UNINUMBR)

etable(r, 
       signif.code = c("***" = 0.01, "**" = 0.05, "*" = 0.10),
       headers = c("Sophisticated", "Above Med Age", "Above Med Income"))

```

