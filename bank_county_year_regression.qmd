---
title: "Bank–County Panel: Deposit Retention Through Remaining Branches"
author: "Generated Output"
format:
  html:
    toc: true
    toc-depth: 3
    code-overflow: scroll
    self-contained: true
execute:
  echo: true
  warning: false
  message: false
---

## Overview

This notebook builds a **bank–county–year** panel to study how deposits evolve at **remaining branches** following branch closures.

### What we can (and cannot) measure
- We can track deposits **only through observed branches**.  
- If a bank closes all branches in a county and retains deposits digitally, those deposits may not appear in that county in branch-level data.  
- Therefore, the analysis is best interpreted as **retention / reallocation through remaining local branches**.

### Empirical object of interest
We aggregate deposits for:
- **Closed branches**: branches that close in year *t* but had deposits in *t-1*.
- **Remaining branches**: branches that survive and exist in both *t-1* and *t+1* (so we can track outcomes consistently around the closure event).

We then estimate how the deposits at remaining branches change with the intensity of deposits closed in the same bank–county–year, with flexible fixed effects and robustness checks.

---

## 0. Environment and configuration

**Notes**
- This chunk loads packages and defines analysis parameters.
- We also define an `output_dir` and create it if needed.
- You should edit file paths as necessary.

```{r}
rm(list = ls())

library(data.table)
library(stringr)
library(fixest)
library(ggplot2)
library(DescTools)
library(lubridate)
library(ggfixest)
# -------------------------
# Inputs (edit paths)
# -------------------------
closure_path   <- "C:/OneDrive/data/closure_opening_data_simple.rds"
app_panel_path <- "C:/OneDrive/data/CH_full_app_reviews_panel.csv"


# -------------------------
# Analysis parameters
# -------------------------
start_year <- 2001
end_year   <- 2024

tail_p <- 0.95                 # Extreme intensity cutoff (top 5%)
min_deposits_threshold <- 1000 # Minimum deposits ($000s)
min_remaining_branches <- 2    # Minimum remaining branches for within-bank variation

# Utility: safe sum
sum_na_safe <- function(x) if (all(is.na(x))) NA_real_ else as.numeric(sum(x, na.rm = TRUE))
safe_max <- function(x) { x <- x[!is.na(x)]; if (length(x) == 0) NA_real_ else max(x) }

# Make fixest output consistent
setFixest_nthreads(0)  # use all available threads
```


```{r}
cat("\n=== LOADING DATA ===\n")

closure_raw <- readRDS(closure_path)
setDT(closure_raw)
closure_raw[, county := str_pad(STCNTYBR, 5, "left", "0")]
closure_raw[, YEAR := as.integer(YEAR)]

app_panel <- fread(app_panel_path)
setDT(app_panel)

app_panel <- app_panel[, .(
  CERT = FDIC_certificate_id,
  YEAR = as.integer(year),
  first_app_available,
  tot_assets,
  reviews_available,
  yearly_rating,
  cumulative_rating
)]


app_panel[, has_app := fifelse(first_app_available == 1, 1L, 0L)]

closure_app <- merge(
  closure_raw,
  app_panel[, .(CERT, YEAR, has_app, tot_assets, reviews_available, yearly_rating, cumulative_rating)],
  by = c("CERT", "YEAR"),
  all.x = TRUE
)
closure_app[is.na(has_app), has_app := 0L]
closure_app[is.na(reviews_available), reviews_available := 0L]

# Bank identifier (use CERT unless you need RSSDID)
closure_app[, bank_id := CERT]

cat("Total branch-year observations:", nrow(closure_app), "\n")
cat("Years covered:", min(closure_app$YEAR), "-", max(closure_app$YEAR), "\n")
cat("Unique banks:", uniqueN(closure_app$bank_id), "\n")
cat("Unique counties:", uniqueN(closure_app$county), "\n")

```

2. Create aligned deposits at t-1 and t+1 (branch level)

Notes

We compute lag/lead deposits by branch (UNINUMBR) and align them only when years are consecutive.

We create flags for branch existence at t-1 and t+1.

This is the backbone of defining “closed” and “remaining” branches in a way that supports clean timing.

```{r}
cat("\n=== CREATING TEMPORAL DEPOSIT VARIABLES ===\n")

setorder(closure_app, UNINUMBR, YEAR)

closure_app[, `:=`(
  dep_lag1   = shift(DEPSUMBR, 1L, type = "lag"),
  year_lag1  = shift(YEAR,     1L, type = "lag"),
  dep_lead1  = shift(DEPSUMBR, 1L, type = "lead"),
  year_lead1 = shift(YEAR,     1L, type = "lead"),
  dep_lead3  = shift(DEPSUMBR, 3L, type = "lead"),
  year_lead3 = shift(YEAR,     3L, type = "lead")
), by = UNINUMBR]

# Align only if consecutive years exist
closure_app[, dep_lag1_aligned  := fifelse(year_lag1  == YEAR - 1L, dep_lag1,  NA_real_)]
closure_app[, dep_lead1_aligned := fifelse(year_lead1 == YEAR + 1L, dep_lead1, NA_real_)]
closure_app[, dep_lead3_aligned := fifelse(year_lead3 == YEAR + 3L, dep_lead3, NA_real_)]

closure_app[, exists_t1  := !is.na(dep_lag1_aligned)  & dep_lag1_aligned  > 0]
closure_app[, exists_tp1 := !is.na(dep_lead1_aligned) & dep_lead1_aligned > 0]
closure_app[, exists_tp3 := !is.na(dep_lead3_aligned) & dep_lead3_aligned > 0]

```


```{r}
cat("\n=== IDENTIFYING BRANCH STATUS ===\n")

closure_app[, is_closed_t := (closed == 1L)]

# Remaining branches: survive year t and exist at t-1 and t+1
closure_app[, is_remaining_branch := (!is_closed_t) & exists_t1 & exists_tp1]
# Remaining branches for t+3 outcome: exist at t-1 and t+3
closure_app[, is_remaining_branch_t3 := (!is_closed_t) & exists_t1 & exists_tp3]

# Closed branches: close in t but existed at t-1 (so we can measure the "closed deposits" base)
closure_app[, is_closed_branch := is_closed_t & exists_t1]

cat("Closed branches (with t-1 deposits):", sum(closure_app$is_closed_branch, na.rm = TRUE), "\n")
cat("Remaining branches (with t-1 and t+1):", sum(closure_app$is_remaining_branch, na.rm = TRUE), "\n")

```


```{r}
cat("\n=== AGGREGATING TO BANK-COUNTY-YEAR LEVEL ===\n")

bank_cty_yr <- closure_app[, .(
  deps_closed_t1 = sum_na_safe(fifelse(is_closed_branch, dep_lag1_aligned, NA_real_)),
  deps_remain_t1 = sum_na_safe(fifelse(is_remaining_branch, dep_lag1_aligned, NA_real_)),
  deps_remain_t  = sum_na_safe(fifelse(is_remaining_branch, DEPSUMBR,       NA_real_)),
  deps_remain_tp1= sum_na_safe(fifelse(is_remaining_branch, dep_lead1_aligned, NA_real_)),
  deps_remain_t1_t3 = sum_na_safe(fifelse(is_remaining_branch_t3, dep_lag1_aligned, NA_real_)),
  deps_remain_tp3= sum_na_safe(fifelse(is_remaining_branch_t3, dep_lead3_aligned, NA_real_)),

  n_closed_branches    = sum(is_closed_branch, na.rm = TRUE),
  n_remaining_branches = sum(is_remaining_branch, na.rm = TRUE),

  has_app = safe_max(has_app),
  reviews_available = safe_max(reviews_available),
  yearly_rating = safe_max(yearly_rating),
  cumulative_rating = safe_max(cumulative_rating)
), by = .(bank_id, county, YEAR)]

# Replace NA sums with 0 where economically meaningful
for (v in c("deps_closed_t1", "deps_remain_t1", "deps_remain_t", "deps_remain_tp1", "deps_remain_t1_t3", "deps_remain_tp3")) {
  bank_cty_yr[is.na(get(v)), (v) := 0]
}
# max(..., na.rm=TRUE) returns -Inf when all NA; replace with sensible defaults
bank_cty_yr[!is.finite(has_app), has_app := 0L]
bank_cty_yr[!is.finite(reviews_available) | reviews_available < 0, reviews_available := 0L]
bank_cty_yr[!is.finite(yearly_rating), yearly_rating := NA_real_]
bank_cty_yr[!is.finite(cumulative_rating), cumulative_rating := NA_real_]

# Bank-level dummies (no time variation within bank): large_bank, then merge
bank_level <- app_panel[, .(large_bank = as.integer(any(tot_assets > 100000000, na.rm = TRUE))), by = .(bank_id = CERT)]
bank_cty_yr <- merge(bank_cty_yr, bank_level, by = "bank_id", all.x = TRUE)
bank_cty_yr[is.na(large_bank), large_bank := 0L]

# Large bank + app dummies (omitted category: small bank)
bank_cty_yr[, large_bank_has_app := fifelse(large_bank == 1L & has_app == 1L, 1L, 0L)]
bank_cty_yr[, large_bank_no_app  := fifelse(large_bank == 1L & has_app == 0L, 1L, 0L)]

# Large good/bad app: median yearly_rating by year among large banks with reviews
rating_med_by_year <- bank_cty_yr[large_bank == 1L & reviews_available == 1L & !is.na(yearly_rating),
                                   .(med_rating = median(yearly_rating, na.rm = TRUE)), by = YEAR]
bank_cty_yr <- merge(bank_cty_yr, rating_med_by_year, by = "YEAR", all.x = TRUE)
bank_cty_yr[, large_good_app := fifelse(large_bank == 1L & reviews_available == 1L & !is.na(yearly_rating) & !is.na(med_rating) & yearly_rating > med_rating, 1L, 0L)]
bank_cty_yr[, large_bad_app  := fifelse(large_bank == 1L & large_good_app == 0L, 1L, 0L)]  # large but not good_app
bank_cty_yr[, med_rating := NULL]

# Good/bad app by cumulative_rating: median cumulative_rating by year among large banks with reviews
rating_cum_med_by_year <- bank_cty_yr[large_bank == 1L & reviews_available == 1L & !is.na(cumulative_rating),
                                      .(med_rating_cum = median(cumulative_rating, na.rm = TRUE)), by = YEAR]
bank_cty_yr <- merge(bank_cty_yr, rating_cum_med_by_year, by = "YEAR", all.x = TRUE)
bank_cty_yr[, large_good_app_cumulative := fifelse(large_bank == 1L & reviews_available == 1L & !is.na(cumulative_rating) & !is.na(med_rating_cum) & cumulative_rating > med_rating_cum, 1L, 0L)]
bank_cty_yr[, large_bad_app_cumulative  := fifelse(large_bank == 1L & large_good_app_cumulative == 0L, 1L, 0L)]  # large but not large_good_app_cumulative
bank_cty_yr[, med_rating_cum := NULL]

```



```{r}
cat("\n=== CREATING OUTCOME VARIABLES ===\n")

# # Level changes at remaining branches
# bank_cty_yr[, delta_deps_remaining := deps_remain_tp1 - deps_remain_t1]
# 
# 
# # Log difference (requires positive deposits at both ends)
# bank_cty_yr[, dlog_deps_remaining := fifelse(deps_remain_t1 > 0 & deps_remain_tp1 > 0,
#                                             log(deps_remain_tp1) - log(deps_remain_t1),
#                                             NA_real_)]
# # Log difference t-1 to t+3 (remaining branches defined as those existing at t-1 and t+3)
# bank_cty_yr[, dlog_deps_remaining_t3 := fifelse(deps_remain_t1_t3 > 0 & deps_remain_tp3 > 0,
#                                                 log(deps_remain_tp3) - log(deps_remain_t1_t3),
#                                                 NA_real_)]



# Retention / migration proxies
bank_cty_yr[, total_deps_bank_county_t1  := deps_closed_t1 + deps_remain_t1]

# Normalize by total initial deposits (common denominator for clean interpretation)
bank_cty_yr[, closure_share := deps_closed_t1 / total_deps_bank_county_t1]
bank_cty_yr[, growth_on_total_t3 := fifelse(
  total_deps_bank_county_t1 > 0,
  (deps_remain_tp3 - deps_remain_t1_t3) / total_deps_bank_county_t1,
  NA_real_
)]
bank_cty_yr[, growth_on_total_t1 := fifelse(
  total_deps_bank_county_t1 > 0,
  (deps_remain_tp1 - deps_remain_t1) / total_deps_bank_county_t1,
  NA_real_
)]

# Bank's market share in county-year (share of county deposits at t-1)
county_deps_t1 <- bank_cty_yr[, .(total_county_deps_t1 = sum(total_deps_bank_county_t1, na.rm = TRUE)), by = .(county, YEAR)]
bank_cty_yr <- merge(bank_cty_yr, county_deps_t1, by = c("county", "YEAR"), all.x = TRUE)
bank_cty_yr[, mkt_share_county_t1 := fifelse(total_county_deps_t1 > 0, total_deps_bank_county_t1 / total_county_deps_t1, NA_real_)]

```



```{r}
cat("\n=== CREATING CLOSURE AND NETWORK CHANGE FLAGS ===\n")

bank_cty_yr[, any_closure_t := as.integer(deps_closed_t1 > 0)]

setorder(bank_cty_yr, bank_id, county, YEAR)

bank_cty_yr[, any_closure_tp1 := shift(any_closure_t, 1L, type = "lead"), by = .(bank_id, county)]
bank_cty_yr[, any_closure_tm1 := shift(any_closure_t, 1L, type = "lag"),  by = .(bank_id, county)]
bank_cty_yr[is.na(any_closure_tp1), any_closure_tp1 := 0L]
bank_cty_yr[is.na(any_closure_tm1), any_closure_tm1 := 0L]

bank_cty_yr[, closure_next_year := any_closure_tp1]
bank_cty_yr[, closure_prev_year := any_closure_tm1]
bank_cty_yr[, closure_t_and_next := as.integer(any_closure_t == 1L & closure_next_year == 1L)]
bank_cty_yr[, closure_t_and_prev := as.integer(any_closure_t == 1L & closure_prev_year == 1L)]

# Current-year branch counts (all branches, not just remaining)
bank_cty_branches <- closure_app[, .(
  n_branches_curr = uniqueN(UNINUMBR)
), by = .(bank_id, county, YEAR)]

bank_cty_closed_counts <- closure_app[closed == 1L, .(
  n_closed_curr = uniqueN(UNINUMBR)
), by = .(bank_id, county, YEAR)]

bank_cty_yr <- merge(bank_cty_yr, bank_cty_branches, by = c("bank_id", "county", "YEAR"), all.x = TRUE)
bank_cty_yr <- merge(bank_cty_yr, bank_cty_closed_counts, by = c("bank_id", "county", "YEAR"), all.x = TRUE)

bank_cty_yr[is.na(n_branches_curr), n_branches_curr := 0L]
bank_cty_yr[is.na(n_closed_curr),   n_closed_curr   := 0L]

# Next-year branch count
setorder(bank_cty_yr, bank_id, county, YEAR)
bank_cty_yr[, n_branches_tp1 := shift(n_branches_curr, 1L, type = "lead"), by = .(bank_id, county)]
bank_cty_yr[is.na(n_branches_tp1), n_branches_tp1 := n_branches_curr]

bank_cty_yr[, delta_branches_t_to_tp1 := n_branches_tp1 - n_branches_curr]

# Clean flags
bank_cty_yr[, clean_no_change_if_no_closure :=
              as.integer(any_closure_t == 0L & delta_branches_t_to_tp1 == 0L)]

bank_cty_yr[, clean_only_current_closures :=
              as.integer(any_closure_t == 1L &
                         delta_branches_t_to_tp1 == -n_closed_curr &
                         any_closure_tp1 == 0L)]

bank_cty_yr[, clean_next_year_network :=
              as.integer((any_closure_t == 0L & clean_no_change_if_no_closure == 1L) |
                         (any_closure_t == 1L & clean_only_current_closures == 1L))]


# View(bank_cty_yr[bank_id==9 & county=="23015"])

```


```{r}
cat("\n=== IDENTIFYING EXTREME CLOSURE INTENSITY ===\n")

bank_cty_yr[, closure_intensity :=
              fifelse(deps_closed_t1 > 0 & deps_remain_t1 > 0,
                      deps_closed_t1 / deps_remain_t1,
                      NA_real_)]

cut_intensity <- bank_cty_yr[
  deps_closed_t1 > 0 & !is.na(closure_intensity),
  quantile(closure_intensity, probs = tail_p, na.rm = TRUE)
]

bank_cty_yr[, extreme_intensity_pctl :=
              as.integer(deps_closed_t1 > 0 &
                         !is.na(closure_intensity) &
                         (closure_intensity >= cut_intensity | closure_intensity < 0.01))]

cat("Extreme intensity cutoff (", tail_p*100, "th percentile):", round(cut_intensity, 3), "\n")
cat("Observations flagged as extreme:", sum(bank_cty_yr$extreme_intensity_pctl, na.rm = TRUE), "\n")

```

```{r}
cat("\n=== CHANGE_VISITS: BRANCH-LEVEL THEN BANK-LEVEL (weighted by 2019) ===\n")

library(DescTools)
library(lubridate)
data_dir_visits <- "C:/OneDrive/data/nrs_branch_closure"
branch_visits <- readRDS(file.path(data_dir_visits, "bank_branch_visits_count_2019_2022.rds"))
setDT(branch_visits)
branch_visits[, yr := year(DATE_RANGE_START)]
branch_visits <- branch_visits[yr %in% c(2019, 2021)]
# One bank_id per branch (most recent year in closure_app)
branch_bank <- closure_app[order(UNINUMBR, -YEAR)][, .SD[1], by = UNINUMBR][, .(UNINUMBR, bank_id)]
branch_visits <- merge(branch_visits, branch_bank, by = "UNINUMBR", all.x = TRUE)
# Total visits per bank in each year, then drop_in_visits = (2019 - 2021) / 2019
bank_change <- branch_visits[, .(total_visits = sum(RAW_VISITOR_COUNTS, na.rm = TRUE)), by = .(bank_id, yr)]
bank_change <- dcast(bank_change, bank_id ~ yr, value.var = "total_visits")
bank_change[, drop_in_visits := (`2019` - `2021`) / `2019`]
bank_change[, drop_in_visits := Winsorize(drop_in_visits, quantile(drop_in_visits, probs = c(0.01, 0.99), na.rm = TRUE))]
bank_change[, high_drop_visits := as.integer(drop_in_visits > median(drop_in_visits, na.rm = TRUE))]
cat("Bank-level drop_in_visits (total visits 2019 vs 2021): ", nrow(bank_change), " banks.\n")
```

```{r}
cat("\n=== DEFINING REGRESSION SAMPLES ===\n")

# Bank-level top4 (no time variation within bank)
top4_cert <- c(628L, 3510L, 3511L, 7213L)
bank_top4 <- unique(bank_cty_yr[, .(bank_id)])
bank_top4[, top4_bank := fifelse(bank_id %in% top4_cert, 1L, 0L)]
bank_cty_yr[, top4_bank := NULL]
bank_cty_yr <- merge(bank_cty_yr, bank_top4, by = "bank_id")


reg_base <- bank_cty_yr[
  YEAR >= start_year & YEAR <= end_year &
    n_remaining_branches > 0 &
    total_deps_bank_county_t1 > 0 &
    !(is.na(growth_on_total_t3) | is.na(growth_on_total_t1))
]

reg_base[,state:=substr(county,1,2)]
reg_base <- merge(reg_base, bank_change, by = "bank_id", all.x = TRUE)

p05_growth <- reg_base[, quantile(growth_on_total_t3, probs = 0.025, na.rm = TRUE)]
reg_base[growth_on_total_t3 < p05_growth, growth_on_total_t3 := p05_growth]
p95_growth <- reg_base[, quantile(growth_on_total_t3, probs = 0.975, na.rm = TRUE)]
reg_base[growth_on_total_t3 > p95_growth, growth_on_total_t3 := p95_growth]


p05_growth <- reg_base[, quantile(growth_on_total_t1, probs = 0.025, na.rm = TRUE)]
reg_base[growth_on_total_t1 < p05_growth, growth_on_total_t1 := p05_growth]
p95_growth <- reg_base[, quantile(growth_on_total_t1, probs = 0.975, na.rm = TRUE)]
reg_base[growth_on_total_t1 > p95_growth, growth_on_total_t1 := p95_growth]


cat("Base sample size:", nrow(reg_base), "\n")
cat("  - With closures:", sum(reg_base$any_closure_t), "\n")
cat("  - Without closures:", sum(reg_base$any_closure_t == 0), "\n")

reg_base[, include_main := extreme_intensity_pctl == 0 ]

reg_main <- reg_base[include_main == 1]
reg_main <- reg_main[any_closure_t == 1 | (any_closure_t == 0L & clean_no_change_if_no_closure == 1L)]

cat("Main sample size:", nrow(reg_main), "\n")
cat("  - With closures:", sum(reg_main$any_closure_t), "\n")
cat("  - Without closures:", sum(reg_main$any_closure_t == 0), "\n")

reg_no_sequential <- reg_main[closure_t_and_next == 0 & closure_t_and_prev == 0]
cat("No sequential closures sample:", nrow(reg_no_sequential), "\n")

exit_bc <- bank_cty_yr[
  YEAR >= start_year & YEAR <= end_year &
    deps_closed_t1 > 0 &
    n_remaining_branches == 0
]

cat("\n=== EXIT DIAGNOSTICS ===\n")
cat("Bank-county-years with closures & NO remaining branches:", nrow(exit_bc), "\n")
cat("Exit share among closure observations:",
    round(nrow(exit_bc) / max(1, nrow(bank_cty_yr[YEAR >= start_year & YEAR <= end_year & deps_closed_t1 > 0])), 4), "\n")

```


```{r}
setFixest_fml(
  ..fixef   = ~ bank_id^YEAR + county^YEAR,
  ..controls = ~ log1p(total_deps_bank_county_t1) + log1p(n_remaining_branches) + mkt_share_county_t1,
  ..depvar  = ~ growth_on_total_t1
)



setFixest_etable(
  signif.code = c("***" = 0.01, "**" = 0.05, "*" = 0.1),
  se.below = T
  )
```


```{r}
cat("\n=== RUNNING MAIN REGRESSIONS ===\n")



r_main <- list()

r_main[[1]] <- feols(..depvar ~ closure_share + ..controls | ..fixef,
                     data = reg_main, vcov = ~ bank_id)
r_main[[2]] <- feols(..depvar ~ closure_share + ..controls | ..fixef,
                     data = reg_main[YEAR < 2012], vcov = ~ bank_id)
r_main[[3]] <- feols(..depvar ~ closure_share + ..controls | ..fixef,
                     data = reg_main[YEAR %in% 2012:2019], vcov = ~ bank_id)
r_main[[4]] <- feols(..depvar ~ closure_share + ..controls | ..fixef,
                     data = reg_main[YEAR >= 2020], vcov = ~ bank_id)

etable(r_main, headers = c("All", "Pre 2012", "2012-2019", "2020-2024"))

```

### 12b. closure_share coefficient by 4-year period (2001–2024)

```{r}
# Run main regression separately for each year, extract closure_share coefficient
# Non-overlapping 4-year windows ending in 2024: 2001-2004, 2005-2008, ..., 2021-2024
years <- seq(2001, 2021, by = 3)  # each window is (y, y+1, y+2, y+3)
coef_by_year <- data.frame(year = numeric(), coef = numeric(), se = numeric(), n = integer())

for (y in years) {
  dt <- reg_main[YEAR %in% c(y, y + 1, y + 2)]
  if (nrow(dt) < 400) next  # skip periods with too few observations
  fit <- try(feols(..depvar ~ closure_share + ..controls | ..fixef,
                   data = dt, vcov = ~ bank_id), silent = TRUE)
  if (inherits(fit, "try-error")) next
  c <- coef(fit)["closure_share"]
  s <- sqrt(vcov(fit)["closure_share", "closure_share"])
  coef_by_year <- rbind(coef_by_year, data.frame(year = y + 1, coef = c, se = s, n = nobs(fit)))
}

ggplot(coef_by_year, aes(x = year, y = coef)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = coef - 1.96 * se, ymax = coef + 1.96 * se), width = 0.2, linewidth = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  labs(x = "Year (midpoint of 3-year window)", y = "closure_share coefficient",
       title = "closure_share coefficient by 4-year period (main regression)") +
  theme_minimal()
```

### 12c. Main regressions with has_app interaction

```{r}
cat("\n=== MAIN REGRESSIONS: HAS_APP INTERACTION ===\n")

r_app <- list()
r_app[[1]] <- feols(..depvar ~ closure_share * has_app + ..controls | ..fixef,
                    data = reg_main[YEAR %in% 2012:2019], vcov = ~ bank_id)
r_app[[2]] <- feols(..depvar ~ closure_share * large_bank_has_app + closure_share * large_bank_no_app  + ..controls | ..fixef,
                    data = reg_main[YEAR >= 2020], vcov = ~ bank_id)
r_app[[3]] <- feols(..depvar ~ closure_share * large_good_app + closure_share * large_bad_app  + ..controls | ..fixef,
                    data = reg_main[YEAR >= 2020], vcov = ~ bank_id)
r_app[[4]] <- feols(..depvar ~ closure_share * large_good_app_cumulative + closure_share * large_bad_app_cumulative  + ..controls | ..fixef,
                    data = reg_main[YEAR >= 2020], vcov = ~ bank_id)


etable(r_app, headers = c("2012-2019", "2012-2019", "2020-2024", "2020-2024"),order=c("closure_share"))
```

```{r}
r_visits <- list()

r_visits[[1]] <- feols(..depvar ~ closure_share * drop_in_visits   + ..controls | ..fixef,
                    data = reg_main[YEAR >= 2020], vcov = ~ bank_id)
r_visits[[2]] <- feols(..depvar ~ closure_share * high_drop_visits   + ..controls | ..fixef,
                    data = reg_main[YEAR >= 2020], vcov = ~ bank_id)
r_visits[[3]] <- feols(..depvar ~ closure_share * high_drop_visits   + ..controls | ..fixef,
                    data = reg_main[YEAR >= 2020 & large_bank==1], vcov = ~ bank_id)
r_visits[[4]] <- feols(..depvar ~ closure_share * high_drop_visits   + ..controls | ..fixef,
                    data = reg_main[YEAR >= 2020 & large_bank==0], vcov = ~ bank_id)

etable(r_visits, headers = c("2020-2024", "2020-2024", "Large", "Small"),order=c("closure_share"))
```

### 12d. Main regressions with large_bank interaction (>$100B assets)

```{r}
cat("\n=== MAIN REGRESSIONS: LARGE_BANK INTERACTION (>$100B) ===\n")

r_large <- list()
r_large[[1]] <- feols(..depvar ~ closure_share * large_bank + ..controls | ..fixef,
                      data = reg_base, vcov = ~ bank_id)
r_large[[2]] <- feols(..depvar ~ closure_share * large_bank + ..controls | ..fixef,
                      data = reg_main, vcov = ~ bank_id)
r_large[[3]] <- feols(..depvar ~ closure_share * large_bank + ..controls | ..fixef,
                      data = reg_main[YEAR < 2012], vcov = ~ bank_id)
r_large[[4]] <- feols(..depvar ~ closure_share * large_bank + ..controls | ..fixef,
                      data = reg_main[YEAR %in% 2012:2019], vcov = ~ bank_id)
r_large[[5]] <- feols(..depvar ~ closure_share * large_bank + ..controls | ..fixef,
                      data = reg_main[YEAR >= 2020], vcov = ~ bank_id)

etable(r_large, headers = c("Base", "Main", "Pre 2012", "2012-2019", "2020-2024"),order=c("closure_share"))
```

```{r}
# Descriptive stats for depvar (growth_on_total_t1) and closure_share by period and any_closure_t
reg_main[, period := fifelse(YEAR %in% 2012:2019, "2012-2019", fifelse(YEAR >= 2020, "2020-2024", NA_character_))]
desc_stats <- reg_main[!is.na(period), .(
  N = .N,
  depvar_mean = round(mean(growth_on_total_t1, na.rm = TRUE), 3),
  depvar_sd   = round(sd(growth_on_total_t1, na.rm = TRUE), 3),
  closure_share_mean = round(mean(closure_share, na.rm = TRUE), 3),
  closure_share_sd   = round(sd(closure_share, na.rm = TRUE), 3)
), keyby = .(period, any_closure_t)]
setnames(desc_stats, "any_closure_t", "any_closure")
cat("\n=== Descriptive stats: depvar (growth_on_total_t1) and closure_share by period and any_closure ===\n\n")
md_table(desc_stats)
reg_main[, period := NULL]
```

```{r}
ggplot(reg_main, aes(x = growth_on_total_t1, fill = factor(any_closure_t))) +
  geom_density(alpha = 0.5) +
  labs(x = "Deposit Growth", y = "Density") +
  theme_minimal()
```





```{r}
cat("\n=== SUN & ABRAHAM: BY TIME PERIOD ===\n")

# Step 0: Create total deposits variable at bank-county-year level
bank_cty_yr_total <- closure_app[, .(
  total_deps_all_branches = sum(DEPSUMBR, na.rm = TRUE),
  n_branches_all = .N
), by = .(bank_id, county, YEAR)]

# Step 1: Identify first closure year for treated bank-counties
first_closure <- bank_cty_yr[
  any_closure_t == 1,
  .(cohort = min(YEAR)),
  by = .(bank_id, county)
]

# Step 2: Start with total deposits data and add cohort
reg_sunab <- merge(
  bank_cty_yr_total,
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Step 3: Sample never-treated bank-counties (50% sample)
set.seed(123)
never_treated_bc <- unique(reg_sunab[is.na(cohort), .(bank_id, county)])
sampled_never_treated <- never_treated_bc[sample(.N, max(1, .N * 0.5))]

# Step 4: Filter dataset
reg_sunab <- reg_sunab[
  (!is.na(cohort) & YEAR >= cohort - 3 & YEAR <= cohort + 3) |
  (is.na(cohort) & paste(bank_id, county) %in% paste(sampled_never_treated$bank_id, sampled_never_treated$county))
]

# Step 5: Set cohort = 10000 for never-treated
reg_sunab[is.na(cohort), cohort := 10000]

# Step 6: Create unit ID
reg_sunab[, unit_id := .GRP, by = .(bank_id, county)]

# Step 7: Run sunab for each period
sunab_pre2012 <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1) | 
    unit_id + YEAR,
  data = reg_sunab[YEAR < 2012],
  vcov = ~ bank_id
)

sunab_2012_2019 <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1) | 
    unit_id + YEAR,
  data = reg_sunab[YEAR >= 2012 & YEAR <= 2019],
  vcov = ~ bank_id
)

sunab_2020_2024 <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1) | 
    unit_id + YEAR,
  data = reg_sunab[YEAR >= 2020],
  vcov = ~ bank_id
)

# etable(sunab_pre2012,sunab_2012_2019,sunab_2020_2024)

ggiplot(sunab_pre2012,
        main = "Sun & Abraham: Pre 2012",
        xlab = "Years Relative to First Closure",
        ylab = "Log Deposits (All Branches)")

ggiplot(sunab_2012_2019,
        main = "Sun & Abraham: 2012-2019",
        xlab = "Years Relative to First Closure",
        ylab = "Log Deposits (All Branches)")

ggiplot(sunab_2020_2024,
        main = "Sun & Abraham: 2020-2024",
        xlab = "Years Relative to First Closure",
        ylab = "Log Deposits (All Branches)")

```


```{r}
cat("\n=== SUN & ABRAHAM: CONSISTENT BRANCH SET ===\n")

# Step 1: Identify first closure year for treated bank-counties
first_closure <- bank_cty_yr[
  any_closure_t == 1,
  .(cohort = min(YEAR)),
  by = .(bank_id, county)
]

# Step 2: Identify which branches to EXCLUDE (closed branches)
# For each bank-county, find branches that close at cohort year
closed_branches <- closure_app[, .(
  bank_id, 
  county, 
  YEAR, 
  UNINUMBR, 
  is_closed = closed == 1L,
  DEPSUMBR
)]

# Add cohort to identify when closures happen
closed_branches <- merge(
  closed_branches,
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Flag branches that close at cohort year
closed_branches[, closes_at_cohort := is_closed & YEAR == cohort]

# Get list of branch IDs that close at cohort
branches_to_exclude <- closed_branches[
  closes_at_cohort == TRUE, 
  .(UNINUMBR, bank_id, county)
]

cat("Branches that close at cohort year:", nrow(branches_to_exclude), "\n")

# Step 3: Create deposits EXCLUDING branches that will close
# This gives us a consistent set of branches across the entire window
bank_cty_yr_consistent <- closure_app[
  # Exclude branches that close at cohort year
  !UNINUMBR %in% branches_to_exclude$UNINUMBR
][, .(
  deps_consistent = sum(DEPSUMBR, na.rm = TRUE),
  n_branches_consistent = .N
), by = .(bank_id, county, YEAR)]

cat("Created consistent deposit series\n")

# Step 4: Merge with cohort info
reg_sunab <- merge(
  bank_cty_yr_consistent,
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Step 5: Sample never-treated bank-counties
set.seed(123)
never_treated_bc <- unique(reg_sunab[is.na(cohort), .(bank_id, county)])
sampled_never_treated <- never_treated_bc[sample(.N, max(1, .N * 0.25))]

# Step 6: Filter dataset
reg_sunab <- reg_sunab[
  # Treated in ±3 window
  (!is.na(cohort) & YEAR >= cohort - 3 & YEAR <= cohort + 3) |
  # OR sampled never-treated (all years)
  (is.na(cohort) & paste(bank_id, county) %in% paste(sampled_never_treated$bank_id, sampled_never_treated$county))
]

# Step 7: Set cohort = 10000 for never-treated
reg_sunab[is.na(cohort), cohort := 10000]

# Step 8: Create unit ID
reg_sunab[, unit_id := .GRP, by = .(bank_id, county)]

# Step 9: Run sunab with consistent branch set for each period
sunab_consistent_pre2012 <- feols(
  log1p(deps_consistent) ~ sunab(cohort, YEAR, ref.p = -1) | 
    unit_id + YEAR,
  data = reg_sunab[YEAR < 2012],
  vcov = ~ bank_id
)

sunab_consistent_2012_2019 <- feols(
  log1p(deps_consistent) ~ sunab(cohort, YEAR, ref.p = -1) | 
    unit_id + YEAR,
  data = reg_sunab[YEAR >= 2012 & YEAR <= 2019],
  vcov = ~ bank_id
)

sunab_consistent_2020_2024 <- feols(
  log1p(deps_consistent) ~ sunab(cohort, YEAR, ref.p = -1) | 
    unit_id + YEAR,
  data = reg_sunab[YEAR >= 2020],
  vcov = ~ bank_id
)

etable(sunab_consistent_pre2012, sunab_consistent_2012_2019, sunab_consistent_2020_2024)

# Step 10: Plots by period
ggiplot(sunab_consistent_pre2012,
        main = "Sun & Abraham (Consistent Branch Set): Pre 2012",
        xlab = "Years Relative to First Closure",
        ylab = "Log Deposits (Surviving Branches)")

ggiplot(sunab_consistent_2012_2019,
        main = "Sun & Abraham (Consistent Branch Set): 2012-2019",
        xlab = "Years Relative to First Closure",
        ylab = "Log Deposits (Surviving Branches)")

ggiplot(sunab_consistent_2020_2024,
        main = "Sun & Abraham (Consistent Branch Set): 2020-2024",
        xlab = "Years Relative to First Closure",
        ylab = "Log Deposits (Surviving Branches)")

```


```{r}
cat("\n=== SUN & ABRAHAM: MEMORY-EFFICIENT VERSION (FIXED) ===\n")

# Step 1: Identify first closure year for treated bank-counties
first_closure <- bank_cty_yr[
  any_closure_t == 1,
  .(cohort = min(YEAR)),
  by = .(bank_id, county)
]

# Step 2: Add cohort to reg_base
reg_base[, cohort := NULL]  # Remove if exists
reg_base <- merge(
  reg_base,
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Step 3: Sample never-treated bank-counties
set.seed(123)
never_treated_bc <- unique(reg_base[is.na(cohort), .(bank_id, county)])
sampled_never_treated <- never_treated_bc[sample(.N, max(1, .N * 0.25))]

# Step 4: Filter dataset
reg_sunab <- reg_base[
  # Treated in ±3 window
  (!is.na(cohort) & YEAR >= cohort - 3 & YEAR <= cohort + 3) |
  # OR sampled never-treated (all years)
  (is.na(cohort) & paste(bank_id, county) %in% paste(sampled_never_treated$bank_id, sampled_never_treated$county))
]

reg_sunab[, unit_id := .GRP, by = .(bank_id, county)]

# Step 5: Set cohort = 10000 for never-treated
reg_sunab[is.na(cohort), cohort := 10000]

# Step 6: Run sunab
sunab_model <- feols(
  log1p(n_remaining_branches) ~ sunab(cohort, YEAR, ref.p = -1) | 
    bank_id^county + YEAR,
  data = reg_sunab,
  vcov = ~ bank_id
)

# Step 7: Plot
ggiplot(sunab_model, 
      main = "Sun & Abraham: With Sampled Never-Treated Controls")
```





--- ignore

```{r}
cat("\n=== SUN & ABRAHAM: TOTAL DEPOSITS (ALL BRANCHES) ===\n")

# Step 0: Create total deposits variable at bank-county-year level
bank_cty_yr_total <- closure_app[, .(
  total_deps_all_branches = sum(DEPSUMBR, na.rm = TRUE),
  n_branches_all = .N
), by = .(bank_id, county, YEAR)]

# Step 1: Identify first closure year for treated bank-counties
first_closure <- bank_cty_yr[
  any_closure_t == 1,
  .(cohort = min(YEAR)),
  by = .(bank_id, county)
]

# Step 2: Start with total deposits data and add cohort
reg_sunab <- merge(
  bank_cty_yr_total,
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Step 3: Sample never-treated bank-counties (20% sample to save memory)
set.seed(123)
never_treated_bc <- unique(reg_sunab[is.na(cohort), .(bank_id, county)])
sampled_never_treated <- never_treated_bc[sample(.N, max(1, .N * 0.5))]

# Step 4: Filter dataset
reg_sunab <- reg_sunab[
  # Treated in ±3 window
  (!is.na(cohort) & YEAR >= cohort - 3 & YEAR <= cohort + 3) |
  # OR sampled never-treated (all years)
  (is.na(cohort) & paste(bank_id, county) %in% paste(sampled_never_treated$bank_id, sampled_never_treated$county))
]

# Step 5: Set cohort = 10000 for never-treated
reg_sunab[is.na(cohort), cohort := 10000]

# Step 6: Create unit ID
reg_sunab[, unit_id := .GRP, by = .(bank_id, county)]

# Step 7: Run sunab with total deposits
sunab_model <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1) | 
    unit_id + YEAR,
  data = reg_sunab,
  vcov = ~ bank_id
)

# Step 8: Plot
ggiplot(sunab_model, 
      main = "Sun & Abraham: Total Deposits (All Branches)",
      xlab = "Years Relative to First Closure",
      ylab = "Log Deposits (All Branches)")

# Step 9: Summary
etable(sunab_model)

```























```{r}
cat("\n=== SUN & ABRAHAM: CLEAN NETWORK CHANGES ONLY ===\n")

# Step 0: Create total deposits variable at bank-county-year level
bank_cty_yr_total <- closure_app[, .(
  total_deps_all_branches = sum(DEPSUMBR, na.rm = TRUE),
  n_branches_all = .N
), by = .(bank_id, county, YEAR)]

# Step 1: Identify first closure year for treated bank-counties
first_closure <- bank_cty_yr[
  any_closure_t == 1,
  .(cohort = min(YEAR)),
  by = .(bank_id, county)
]

# Step 2: Start with total deposits data and add cohort
reg_sunab <- merge(
  bank_cty_yr_total,
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Step 3: Calculate branch changes for each bank-county-year
setorder(reg_sunab, bank_id, county, YEAR)
reg_sunab[, n_branches_lag := shift(n_branches_all, 1, type = "lag"), by = .(bank_id, county)]
reg_sunab[, branch_change := n_branches_all - n_branches_lag]

# Step 4: For each bank-county, enforce clean branch-count patterns in [-3, 3]
reg_sunab[, event_time := fifelse(is.na(cohort), -1000, YEAR - cohort)]

# Treated: stable in pre (-3:-1), stable in post (1:3), and only break at t=0
clean_treated <- reg_sunab[
  !is.na(cohort) & event_time >= -3 & event_time <= 3
][, .(
  has_all_event_times = all((-3):3 %in% event_time),
  pre_stable = uniqueN(n_branches_all[event_time %in% -3:-1]) == 1,
  post_stable = uniqueN(n_branches_all[event_time %in% 1:3]) == 1,
  t0_diff_from_pre = n_branches_all[event_time == 0][1] != n_branches_all[event_time == -1][1],
  t0_equals_t1 = n_branches_all[event_time == 0][1] == n_branches_all[event_time == 1][1]
), by = .(bank_id, county)]

# Keep only treated units where the only branch-count break is at t=0
clean_treated <- clean_treated[
  has_all_event_times & pre_stable & post_stable & t0_diff_from_pre & t0_equals_t1
][, .(bank_id, county)]

cat("Treated units with clean network changes:", nrow(clean_treated), "\n")

# Never-treated controls: for each observation, require constant branch count in [t-3, t+3]
reg_sunab[is.na(cohort), control_window_ok := {
  out <- rep(FALSE, .N)
  yrs <- YEAR
  nbr <- n_branches_all
  for (i in seq_len(.N)) {
    req_yrs <- (yrs[i] - 3):(yrs[i] + 3)
    idx <- match(req_yrs, yrs)
    if (all(!is.na(idx))) {
      out[i] <- uniqueN(nbr[idx]) == 1
    }
  }
  out
}, by = .(bank_id, county)]

clean_never_treated <- unique(reg_sunab[
  is.na(cohort) & control_window_ok == TRUE,
  .(bank_id, county)
])

cat("Never-treated units with no branch changes:", nrow(clean_never_treated), "\n")

# Step 5: Sample from clean never-treated (50% to save memory)
set.seed(123)
sampled_never_treated <- clean_never_treated[sample(.N, max(1, .N * 0.5))]

cat("Sampled never-treated:", nrow(sampled_never_treated), "\n")

# Step 6: Filter to clean units only
reg_sunab_clean <- reg_sunab[
  # Clean treated in ±3 window
  (paste(bank_id, county) %in% paste(clean_treated$bank_id, clean_treated$county) & 
   event_time >= -3 & event_time <= 3) |
  # OR sampled clean never-treated observations with stable [-3, +3] branch counts
  (paste(bank_id, county) %in% paste(sampled_never_treated$bank_id, sampled_never_treated$county) &
     control_window_ok == TRUE)
]

# Step 7: Set cohort = 10000 for never-treated
reg_sunab_clean[is.na(cohort), cohort := 10000]

# Step 8: Create unit ID
reg_sunab_clean[, unit_id := .GRP, by = .(bank_id, county)]

# Step 9: Run sunab with total deposits
sunab_model_clean <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1) | 
    unit_id + YEAR,
  data = reg_sunab_clean,
  vcov = ~ bank_id
)

# Step 10: Plot
ggiplot(sunab_model_clean, 
      main = "Sun & Abraham: Clean Network Changes Only",
      xlab = "Years Relative to First Closure",
      ylab = "Log Deposits (All Branches)")

# Step 11: Summary
etable(sunab_model_clean)

cat("\nFinal sample size:", nrow(reg_sunab_clean), "\n")
cat("  - Clean treated:", sum(reg_sunab_clean$cohort != 10000), "\n")
cat("  - Clean never-treated:", sum(reg_sunab_clean$cohort == 10000), "\n")
```




```{r}
cat("\n=== SUN & ABRAHAM: DOSE-RESPONSE WITH CLOSURE_SHARE ===\n")

# Step 0: Create total deposits variable at bank-county-year level
bank_cty_yr_total <- closure_app[, .(
  total_deps_all_branches = sum(DEPSUMBR, na.rm = TRUE),
  n_branches_all = .N
), by = .(bank_id, county, YEAR)]

# Merge with your existing bank_cty_yr to get closure_share
bank_cty_yr_total <- merge(
  bank_cty_yr_total,
  bank_cty_yr[, .(bank_id, county, YEAR, closure_share, deps_closed_t1, total_deps_bank_county_t1)],
  by = c("bank_id", "county", "YEAR"),
  all.x = TRUE
)

# Fill NAs
bank_cty_yr_total[is.na(closure_share), closure_share := 0]

# Step 1: Identify first closure year for treated bank-counties
first_closure <- bank_cty_yr[
  any_closure_t == 1,
  .(cohort = min(YEAR)),
  by = .(bank_id, county)
]

# Step 2: Add cohort
reg_sunab <- merge(
  bank_cty_yr_total,
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Step 3: Sample never-treated bank-counties
set.seed(123)
never_treated_bc <- unique(reg_sunab[is.na(cohort), .(bank_id, county)])
sampled_never_treated <- never_treated_bc[sample(.N, max(1, .N * 0.2))]

# Step 4: Filter dataset
reg_sunab <- reg_sunab[
  (!is.na(cohort) & YEAR >= cohort - 3 & YEAR <= cohort + 3) |
  (is.na(cohort) & paste(bank_id, county) %in% paste(sampled_never_treated$bank_id, sampled_never_treated$county))
]

# Step 5: Set cohort = 10000 for never-treated
reg_sunab[is.na(cohort), cohort := 10000]

# Step 6: Create unit ID
reg_sunab[, unit_id := .GRP, by = .(bank_id, county)]

# Step 7: INTERACTION MODEL - sunab interacted with closure_share
sunab_dose <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1, closure_share) | 
    unit_id + YEAR,
  data = reg_sunab,
  vcov = ~ bank_id
)

# Step 8: Plot
ggiplot(sunab_dose, 
      main = "Sun & Abraham: Dose-Response (Closure Share)",
      xlab = "Years Relative to First Closure",
      ylab = "Effect per Unit of Closure Share")

etable(sunab_dose)
```


```{r}
cat("\n=== SUN & ABRAHAM: MEMORY-EFFICIENT VERSION (FIXED) ===\n")

# Step 1: Identify first closure year for treated bank-counties
first_closure <- bank_cty_yr[
  any_closure_t == 1,
  .(cohort = min(YEAR)),
  by = .(bank_id, county)
]

# Step 2: Add cohort to reg_base
reg_base[, cohort := NULL]  # Remove if exists
reg_base <- merge(
  reg_base,
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Step 3: Sample never-treated bank-counties
set.seed(123)
never_treated_bc <- unique(reg_base[is.na(cohort), .(bank_id, county)])
sampled_never_treated <- never_treated_bc[sample(.N, max(1, .N * 0.25))]

# Step 4: Filter dataset
reg_sunab <- reg_base[
  # Treated in ±3 window
  (!is.na(cohort) & YEAR >= cohort - 3 & YEAR <= cohort + 3) |
  # OR sampled never-treated (all years)
  (is.na(cohort) & paste(bank_id, county) %in% paste(sampled_never_treated$bank_id, sampled_never_treated$county))
]

reg_sunab[, unit_id := .GRP, by = .(bank_id, county)]

# Step 5: Set cohort = 10000 for never-treated
reg_sunab[is.na(cohort), cohort := 10000]

# Step 6: Run sunab
sunab_model <- feols(
  log1p(deps_remain_t) ~ sunab(cohort, YEAR, ref.p = -1) | 
    bank_id^county + YEAR,
  data = reg_sunab,
  vcov = ~ bank_id
)

# Step 7: Plot
ggiplot(sunab_model, 
      main = "Sun & Abraham: With Sampled Never-Treated Controls")
```

