---
title: "Bank–County Panel: Deposit Retention Through Remaining Branches"
author: "Generated Output"
format:
  html:
    toc: true
    toc-depth: 3
    code-overflow: scroll
    self-contained: true
execute:
  echo: true
  warning: false
  message: false
---

```{r}
rm(list = ls())

library(data.table)
library(stringr)
library(lubridate)
library(fixest)
library(ggplot2)
library(DescTools)
library(ggfixest)
library(simplermarkdown)
library(gridExtra)

setFixest_nthreads(0)

# -------------------------
# Paths (edit)
# -------------------------
paths <- list(
  closure_rds = "C:/OneDrive/data/closure_opening_data_simple.rds",
  app_csv     = "C:/OneDrive/data/CH_full_app_reviews_panel.csv",
  visits_dir  = "C:/OneDrive/data/nrs_branch_closure",
  visits_rds  = "bank_branch_visits_count_2019_2022.rds"
)

# -------------------------
# Parameters
# -------------------------
params <- list(
  start_year = 2001L,
  end_year   = 2024L,
  tail_p     = 0.95,      # top 5% closure_intensity flagged as extreme
  never_treated_share = 0.5,
  winsor_p   = c(0.025, 0.975),
  top4_cert  = c(628L, 3510L, 3511L, 7213L),
  assets_large_threshold = 100000000
)

# -------------------------
# Small utilities
# -------------------------
sum_na_safe <- function(x) if (all(is.na(x))) NA_real_ else as.numeric(sum(x, na.rm = TRUE))
safe_max    <- function(x) { x <- x[!is.na(x)]; if (!length(x)) NA_real_ else max(x) }
winsor_dt   <- function(dt, v, p = c(0.025, 0.975)) {
  lo <- dt[, quantile(get(v), probs = p[1], na.rm = TRUE)]
  hi <- dt[, quantile(get(v), probs = p[2], na.rm = TRUE)]
  dt[get(v) < lo, (v) := lo]
  dt[get(v) > hi, (v) := hi]
  invisible(dt)
}
```


```{r}
cat("\n=== LOADING DATA ===\n")

closure_raw <- readRDS(paths$closure_rds)
setDT(closure_raw)
closure_raw[, county := str_pad(STCNTYBR, 5, "left", "0")]
closure_raw[, YEAR := as.integer(YEAR)]

app_panel <- fread(paths$app_csv)
setDT(app_panel)

app_panel <- app_panel[, .(
  CERT = FDIC_certificate_id,
  YEAR = as.integer(year),
  first_app_available,
  tot_assets,
  reviews_available,
  yearly_rating,
  cumulative_rating
)]
app_panel[, has_app := fifelse(first_app_available == 1, 1L, 0L)]

closure_app <- merge(
  closure_raw,
  app_panel[, .(CERT, YEAR, has_app, tot_assets, reviews_available, yearly_rating, cumulative_rating)],
  by = c("CERT", "YEAR"),
  all.x = TRUE
)

# Defaults
closure_app[is.na(has_app), has_app := 0L]
closure_app[is.na(reviews_available), reviews_available := 0L]

# Bank identifier
closure_app[, bank_id := CERT]

cat("Total branch-year observations:", nrow(closure_app), "\n")
cat("Years covered:", min(closure_app$YEAR), "-", max(closure_app$YEAR), "\n")
cat("Unique banks:", uniqueN(closure_app$bank_id), "\n")
cat("Unique counties:", uniqueN(closure_app$county), "\n")

```

```{r}
cat("\n=== CREATING TEMPORAL DEPOSIT VARIABLES ===\n")

setorder(closure_app, UNINUMBR, YEAR)

closure_app[, `:=`(
  dep_lag1   = shift(DEPSUMBR, 1L, type = "lag"),
  year_lag1  = shift(YEAR,     1L, type = "lag"),
  dep_lead1  = shift(DEPSUMBR, 1L, type = "lead"),
  year_lead1 = shift(YEAR,     1L, type = "lead"),
  dep_lead3  = shift(DEPSUMBR, 3L, type = "lead"),
  year_lead3 = shift(YEAR,     3L, type = "lead")
), by = UNINUMBR]

# Align only if consecutive years exist
closure_app[, dep_lag1_aligned  := fifelse(year_lag1  == YEAR - 1L, dep_lag1,  NA_real_)]
closure_app[, dep_lead1_aligned := fifelse(year_lead1 == YEAR + 1L, dep_lead1, NA_real_)]
closure_app[, dep_lead3_aligned := fifelse(year_lead3 == YEAR + 3L, dep_lead3, NA_real_)]

closure_app[, exists_t1  := !is.na(dep_lag1_aligned)  & dep_lag1_aligned  > 0]
closure_app[, exists_tp1 := !is.na(dep_lead1_aligned) & dep_lead1_aligned > 0]
closure_app[, exists_tp3 := !is.na(dep_lead3_aligned) & dep_lead3_aligned > 0]

cat("\n=== IDENTIFYING BRANCH STATUS ===\n")

closure_app[, is_closed_t := (closed == 1L)]

# Remaining branches: survive t and exist at t-1 and t+1 (or t+3 for longer horizon)
closure_app[, is_remaining_branch    := (!is_closed_t) & exists_t1 & exists_tp1]
closure_app[, is_remaining_branch_t3 := (!is_closed_t) & exists_t1 & exists_tp3]

# Closed branches: close in t but existed at t-1
closure_app[, is_closed_branch := is_closed_t & exists_t1]

cat("Closed branches (with t-1 deposits):", sum(closure_app$is_closed_branch, na.rm = TRUE), "\n")
cat("Remaining branches (t-1 & t+1):",     sum(closure_app$is_remaining_branch, na.rm = TRUE), "\n")

```
```{r}
cat("\n=== AGGREGATING TO BANK-COUNTY-YEAR LEVEL ===\n")

bank_cty_yr <- closure_app[, .(
  deps_closed_t1      = sum_na_safe(fifelse(is_closed_branch,        dep_lag1_aligned,  NA_real_)),
  deps_remain_t1      = sum_na_safe(fifelse(is_remaining_branch,     dep_lag1_aligned,  NA_real_)),
  deps_remain_t       = sum_na_safe(fifelse(is_remaining_branch,     DEPSUMBR,          NA_real_)),
  deps_remain_tp1     = sum_na_safe(fifelse(is_remaining_branch,     dep_lead1_aligned, NA_real_)),
  deps_remain_t1_t3   = sum_na_safe(fifelse(is_remaining_branch_t3,  dep_lag1_aligned,  NA_real_)),
  deps_remain_tp3     = sum_na_safe(fifelse(is_remaining_branch_t3,  dep_lead3_aligned, NA_real_)),

  n_closed_branches    = sum(is_closed_branch,     na.rm = TRUE),
  n_remaining_branches = sum(is_remaining_branch,  na.rm = TRUE),

  has_app           = safe_max(has_app),
  reviews_available = safe_max(reviews_available),
  yearly_rating     = safe_max(yearly_rating),
  cumulative_rating = safe_max(cumulative_rating)
), by = .(bank_id, county, YEAR)]

# Replace NA sums with 0
sum_vars <- c("deps_closed_t1","deps_remain_t1","deps_remain_t","deps_remain_tp1","deps_remain_t1_t3","deps_remain_tp3")
for (v in sum_vars) bank_cty_yr[is.na(get(v)), (v) := 0]

# Clean max outputs
bank_cty_yr[!is.finite(has_app), has_app := 0L]
bank_cty_yr[!is.finite(reviews_available) | reviews_available < 0, reviews_available := 0L]
bank_cty_yr[!is.finite(yearly_rating), yearly_rating := NA_real_]
bank_cty_yr[!is.finite(cumulative_rating), cumulative_rating := NA_real_]

# Bank-level: large bank flag (time-invariant)
bank_level <- app_panel[, .(
  large_bank = as.integer(any(tot_assets > params$assets_large_threshold, na.rm = TRUE))
), by = .(bank_id = CERT)]
bank_cty_yr <- merge(bank_cty_yr, bank_level, by = "bank_id", all.x = TRUE)
bank_cty_yr[is.na(large_bank), large_bank := 0L]

# Convenience indicators
bank_cty_yr[, large_bank_has_app := as.integer(large_bank == 1L & has_app == 1L)]
bank_cty_yr[, large_bank_no_app  := as.integer(large_bank == 1L & has_app == 0L)]

# Large good/bad app (yearly rating): median by YEAR among large banks with reviews
rating_med_by_year <- bank_cty_yr[
  large_bank == 1L & reviews_available == 1L & !is.na(yearly_rating),
  .(med_rating = median(yearly_rating, na.rm = TRUE)),
  by = YEAR
]
bank_cty_yr <- merge(bank_cty_yr, rating_med_by_year, by = "YEAR", all.x = TRUE)
bank_cty_yr[, large_good_app := as.integer(large_bank == 1L & reviews_available == 1L &
                                          !is.na(yearly_rating) & !is.na(med_rating) & yearly_rating > med_rating)]
bank_cty_yr[, large_bad_app  := as.integer(large_bank == 1L & large_good_app == 0L)]
bank_cty_yr[, med_rating := NULL]

# Large good/bad app (cumulative rating): median by YEAR among large banks with reviews
rating_cum_med_by_year <- bank_cty_yr[
  large_bank == 1L & reviews_available == 1L & !is.na(cumulative_rating),
  .(med_rating_cum = median(cumulative_rating, na.rm = TRUE)),
  by = YEAR
]
bank_cty_yr <- merge(bank_cty_yr, rating_cum_med_by_year, by = "YEAR", all.x = TRUE)
bank_cty_yr[, large_good_app_cumulative := as.integer(large_bank == 1L & reviews_available == 1L &
                                                     !is.na(cumulative_rating) & !is.na(med_rating_cum) &
                                                     cumulative_rating > med_rating_cum)]
bank_cty_yr[, large_bad_app_cumulative  := as.integer(large_bank == 1L & large_good_app_cumulative == 0L)]
bank_cty_yr[, med_rating_cum := NULL]

```
```{r}
cat("\n=== CREATING OUTCOME VARIABLES ===\n")

bank_cty_yr[, total_deps_bank_county_t1 := deps_closed_t1 + deps_remain_t1]

# Intensity / shares
bank_cty_yr[, closure_share := fifelse(total_deps_bank_county_t1 > 0, deps_closed_t1 / total_deps_bank_county_t1, NA_real_)]

# Growth normalized by total initial deposits
bank_cty_yr[, growth_on_total_t1 := fifelse(
  total_deps_bank_county_t1 > 0,
  (deps_remain_tp1 - deps_remain_t1) / total_deps_bank_county_t1,
  NA_real_
)]
bank_cty_yr[, growth_on_total_t3 := fifelse(
  total_deps_bank_county_t1 > 0,
  (deps_remain_tp3 - deps_remain_t1_t3) / total_deps_bank_county_t1,
  NA_real_
)]

# County totals for market share at t-1
county_deps_t1 <- bank_cty_yr[, .(
  total_county_deps_t1 = sum(total_deps_bank_county_t1, na.rm = TRUE)
), by = .(county, YEAR)]
bank_cty_yr <- merge(bank_cty_yr, county_deps_t1, by = c("county", "YEAR"), all.x = TRUE)
bank_cty_yr[, mkt_share_county_t1 := fifelse(total_county_deps_t1 > 0, total_deps_bank_county_t1 / total_county_deps_t1, NA_real_)]

```

```{r}
cat("\n=== CREATING CLOSURE AND NETWORK CHANGE FLAGS ===\n")

bank_cty_yr[, any_closure_t := as.integer(deps_closed_t1 > 0)]
setorder(bank_cty_yr, bank_id, county, YEAR)

bank_cty_yr[, any_closure_tp1 := shift(any_closure_t, 1L, type = "lead"), by = .(bank_id, county)]
bank_cty_yr[, any_closure_tm1 := shift(any_closure_t, 1L, type = "lag"),  by = .(bank_id, county)]
bank_cty_yr[is.na(any_closure_tp1), any_closure_tp1 := 0L]
bank_cty_yr[is.na(any_closure_tm1), any_closure_tm1 := 0L]

bank_cty_yr[, `:=`(
  closure_next_year  = any_closure_tp1,
  closure_prev_year  = any_closure_tm1,
  closure_t_and_next = as.integer(any_closure_t == 1L & any_closure_tp1 == 1L),
  closure_t_and_prev = as.integer(any_closure_t == 1L & any_closure_tm1 == 1L)
)]

# Current-year branch counts (all branches)
bank_cty_branches <- closure_app[, .(
  n_branches_curr = uniqueN(UNINUMBR)
), by = .(bank_id, county, YEAR)]

bank_cty_closed_counts <- closure_app[closed == 1L, .(
  n_closed_curr = uniqueN(UNINUMBR)
), by = .(bank_id, county, YEAR)]

bank_cty_yr <- merge(bank_cty_yr, bank_cty_branches,      by = c("bank_id","county","YEAR"), all.x = TRUE)
bank_cty_yr <- merge(bank_cty_yr, bank_cty_closed_counts, by = c("bank_id","county","YEAR"), all.x = TRUE)
bank_cty_yr[is.na(n_branches_curr), n_branches_curr := 0L]
bank_cty_yr[is.na(n_closed_curr),   n_closed_curr   := 0L]

# Next-year branch count + delta
setorder(bank_cty_yr, bank_id, county, YEAR)
bank_cty_yr[, n_branches_tp1 := shift(n_branches_curr, 1L, type = "lead"), by = .(bank_id, county)]
bank_cty_yr[is.na(n_branches_tp1), n_branches_tp1 := n_branches_curr]
bank_cty_yr[, delta_branches_t_to_tp1 := n_branches_tp1 - n_branches_curr]

# "Clean" flags
bank_cty_yr[, clean_no_change_if_no_closure :=
              as.integer(any_closure_t == 0L & delta_branches_t_to_tp1 == 0L)]

bank_cty_yr[, clean_only_current_closures :=
              as.integer(any_closure_t == 1L &
                         delta_branches_t_to_tp1 == -n_closed_curr &
                         any_closure_tp1 == 0L)]

bank_cty_yr[, clean_next_year_network :=
              as.integer((any_closure_t == 0L & clean_no_change_if_no_closure == 1L) |
                         (any_closure_t == 1L & clean_only_current_closures == 1L))]

```
```{r}
cat("\n=== IDENTIFYING EXTREME CLOSURE INTENSITY ===\n")

bank_cty_yr[, closure_intensity := fifelse(
  deps_closed_t1 > 0 & deps_remain_t1 > 0,
  deps_closed_t1 / deps_remain_t1,
  NA_real_
)]

cut_intensity <- bank_cty_yr[
  deps_closed_t1 > 0 & !is.na(closure_intensity),
  quantile(closure_intensity, probs = params$tail_p, na.rm = TRUE)
]

bank_cty_yr[, extreme_intensity_pctl := as.integer(
  deps_closed_t1 > 0 &
  !is.na(closure_intensity) &
  (closure_intensity >= cut_intensity | closure_intensity < 0.01)
)]

cat("Extreme intensity cutoff (", params$tail_p*100, "th pct): ", round(cut_intensity, 3), "\n", sep = "")
cat("Flagged extreme observations:", sum(bank_cty_yr$extreme_intensity_pctl, na.rm = TRUE), "\n")

```
```{r}
cat("\n=== CHANGE_VISITS: BANK-LEVEL (2019 vs 2021) ===\n")

branch_visits <- readRDS(file.path(paths$visits_dir, paths$visits_rds))
setDT(branch_visits)

branch_visits[, yr := year(DATE_RANGE_START)]
branch_visits <- branch_visits[yr %in% c(2019, 2021)]

# Attach bank_id to each branch using most recent mapping in closure_app
branch_bank <- closure_app[order(UNINUMBR, -YEAR)][, .SD[1], by = UNINUMBR][, .(UNINUMBR, bank_id)]
branch_visits <- merge(branch_visits, branch_bank, by = "UNINUMBR", all.x = TRUE)

bank_change <- branch_visits[, .(
  total_visits = sum(RAW_VISITOR_COUNTS, na.rm = TRUE)
), by = .(bank_id, yr)]
bank_change <- dcast(bank_change, bank_id ~ yr, value.var = "total_visits")

bank_change[, drop_in_visits := (`2019` - `2021`) / `2019`]

# Winsorize once
bank_change[, drop_in_visits := Winsorize(
  drop_in_visits,
  val = quantile(drop_in_visits, probs = c(0.01, 0.99), na.rm = TRUE)
)]

bank_change[, high_drop_visits := as.integer(drop_in_visits > median(drop_in_visits, na.rm = TRUE))]

cat("Computed visit decline for", nrow(bank_change), "banks.\n")

```
```{r}
cat("\n=== DEFINING REGRESSION SAMPLES ===\n")

# Add top4 flag (time-invariant)
bank_cty_yr[, top4_bank := as.integer(bank_id %in% params$top4_cert)]

reg_base <- bank_cty_yr[
  YEAR >= params$start_year & YEAR <= params$end_year &
    n_remaining_branches > 0 &
    total_deps_bank_county_t1 > 0 &
    !is.na(growth_on_total_t3) & !is.na(growth_on_total_t1)
]

reg_base[, state := substr(county, 1, 2)]
reg_base <- merge(reg_base, bank_change, by = "bank_id", all.x = TRUE)

# Winsorize depvars
winsor_dt(reg_base, "growth_on_total_t3", params$winsor_p)
winsor_dt(reg_base, "growth_on_total_t1", params$winsor_p)

cat("Base sample size:", nrow(reg_base), "\n")
cat("  - With closures:", sum(reg_base$any_closure_t), "\n")
cat("  - Without closures:", sum(reg_base$any_closure_t == 0), "\n")

reg_base[, include_main := extreme_intensity_pctl == 0L]

reg_main <- reg_base[include_main == 1L]
reg_main <- reg_main[any_closure_t == 1L | (any_closure_t == 0L & clean_no_change_if_no_closure == 1L)]

cat("Main sample size:", nrow(reg_main), "\n")
cat("  - With closures:", sum(reg_main$any_closure_t), "\n")
cat("  - Without closures:", sum(reg_main$any_closure_t == 0), "\n")

reg_no_sequential <- reg_main[closure_t_and_next == 0L & closure_t_and_prev == 0L]
cat("No sequential closures sample:", nrow(reg_no_sequential), "\n")

exit_bc <- bank_cty_yr[
  YEAR >= params$start_year & YEAR <= params$end_year &
    deps_closed_t1 > 0 &
    n_remaining_branches == 0
]
cat("\n=== EXIT DIAGNOSTICS ===\n")
cat("Bank-county-years with closures & NO remaining branches:", nrow(exit_bc), "\n")
cat("Exit share among closure observations:",
    round(nrow(exit_bc) / max(1, nrow(bank_cty_yr[YEAR >= params$start_year & YEAR <= params$end_year & deps_closed_t1 > 0])), 4), "\n")

```
```{r}
setFixest_fml(
  ..fixef    = ~ bank_id^YEAR + county^YEAR,
  ..controls = ~ log1p(total_deps_bank_county_t1) + log1p(n_remaining_branches) + mkt_share_county_t1,
  ..depvar   = ~ growth_on_total_t1
)
setFixest_etable(
  signif.code = c("***" = 0.01, "**" = 0.05, "*" = 0.1),
  se.below = TRUE
)

```



```{r}
cat("\n=== RUNNING MAIN REGRESSIONS ===\n")

r_main <- list(
  "All"       = feols(..depvar ~ closure_share + ..controls | ..fixef, data = reg_main,                     vcov = ~ bank_id),
  "Pre 2012"  = feols(..depvar ~ closure_share + ..controls | ..fixef, data = reg_main[YEAR < 2012],       vcov = ~ bank_id),
  "2012-2019" = feols(..depvar ~ closure_share + ..controls | ..fixef, data = reg_main[YEAR %in% 2012:2019], vcov = ~ bank_id),
  "2020-2024" = feols(..depvar ~ closure_share + ..controls | ..fixef, data = reg_main[YEAR >= 2020],      vcov = ~ bank_id)
)

etable(r_main)

```


```{r}
years <- seq(params$start_year, params$end_year - 2, by = 3)

coef_by_year <- rbindlist(lapply(years, function(y) {
  dt <- reg_main[YEAR %in% c(y, y + 1L, y + 2L)]
  if (nrow(dt) < 400) return(NULL)

  fit <- try(feols(..depvar ~ closure_share + ..controls | ..fixef, data = dt, vcov = ~ bank_id), silent = TRUE)
  if (inherits(fit, "try-error")) return(NULL)

  c  <- coef(fit)["closure_share"]
  se <- sqrt(vcov(fit)["closure_share", "closure_share"])
  data.table(year = y + 1L, coef = as.numeric(c), se = as.numeric(se), n = nobs(fit))
}), fill = TRUE)

ggplot(coef_by_year, aes(x = year, y = coef)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = coef - 1.96 * se, ymax = coef + 1.96 * se),
                width = 0.2, linewidth = 0.3) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  labs(x = "Year (midpoint of 3-year window)", y = "closure_share coefficient",
       title = "closure_share coefficient by 3-year windows") +
  theme_minimal()

```
```{r}
cat("\n=== MAIN REGRESSIONS: HAS_APP / LARGE / RATINGS ===\n")

r_app <- list(
  "2012-2019: has_app" = feols(..depvar ~ closure_share * has_app + ..controls | ..fixef,
                               data = reg_main[YEAR %in% 2012:2019], vcov = ~ bank_id),

  "2020-2024: large x app" = feols(..depvar ~ closure_share * large_bank_has_app + closure_share * large_bank_no_app + ..controls | ..fixef,
                                   data = reg_main[YEAR >= 2020], vcov = ~ bank_id),

  "2020-2024: yearly good/bad" = feols(..depvar ~ closure_share * large_good_app + closure_share * large_bad_app + ..controls | ..fixef,
                                       data = reg_main[YEAR >= 2020], vcov = ~ bank_id),

  "2020-2024: cum good/bad" = feols(..depvar ~ closure_share * large_good_app_cumulative + closure_share * large_bad_app_cumulative + ..controls | ..fixef,
                                    data = reg_main[YEAR >= 2020], vcov = ~ bank_id)
)

etable(r_app, order = "closure_share")

```

```{r}
cat("\n=== MAIN REGRESSIONS: VISITS (2020+) ===\n")

r_visits <- list(
  "Drop (cont.)" = feols(..depvar ~ closure_share * drop_in_visits + ..controls | ..fixef,
                         data = reg_main[YEAR >= 2020], vcov = ~ bank_id),

  "Drop (high)"  = feols(..depvar ~ closure_share * high_drop_visits + ..controls | ..fixef,
                         data = reg_main[YEAR >= 2020], vcov = ~ bank_id),

  "High drop: large" = feols(..depvar ~ closure_share * high_drop_visits + ..controls | ..fixef,
                             data = reg_main[YEAR >= 2020 & large_bank == 1L], vcov = ~ bank_id),

  "High drop: small" = feols(..depvar ~ closure_share * high_drop_visits + ..controls | ..fixef,
                             data = reg_main[YEAR >= 2020 & large_bank == 0L], vcov = ~ bank_id)
)

etable(r_visits, order = "closure_share")

```

```{r}
reg_main[, period := fcase(
  YEAR %in% 2012:2019, "2012-2019",
  YEAR >= 2020,        "2020-2024",
  default = NA_character_
)]

desc_stats <- reg_main[!is.na(period), .(
  N = .N,
  depvar_mean = round(mean(growth_on_total_t1, na.rm = TRUE), 3),
  depvar_sd   = round(sd(growth_on_total_t1, na.rm = TRUE), 3),
  closure_share_mean = round(mean(closure_share, na.rm = TRUE), 3),
  closure_share_sd   = round(sd(closure_share, na.rm = TRUE), 3)
), keyby = .(period, any_closure_t)]

setnames(desc_stats, "any_closure_t", "any_closure")
md_table(desc_stats)

reg_main[, period := NULL]

```

```{r}
ggplot(reg_main, aes(x = growth_on_total_t1, fill = factor(any_closure_t))) +
  geom_density(alpha = 0.5) +
  labs(x = "Deposit Growth (t-1 to t+1, / total t-1)", y = "Density") +
  theme_minimal()

```


```{r}
cat("\n=== SUN & ABRAHAM: ALL BRANCH DEPOSITS, BY PERIOD ===\n")

# Total deposits at bank-county-year (all observed branches)
bank_cty_yr_total <- closure_app[, .(
  total_deps_all_branches = sum(DEPSUMBR, na.rm = TRUE),
  n_branches_all = uniqueN(UNINUMBR)
), by = .(bank_id, county, YEAR)]

# First closure year for treated bank-counties
first_closure <- bank_cty_yr[any_closure_t == 1L, .(cohort = min(YEAR)), by = .(bank_id, county)]

reg_sunab_all <- merge(bank_cty_yr_total, first_closure, by = c("bank_id", "county"), all.x = TRUE)

# Sample never-treated bank-counties
set.seed(123)
never_bc <- unique(reg_sunab_all[is.na(cohort), .(bank_id, county)])
keep_never <- never_bc[sample(.N, max(1, floor(.N * 0.50)))]

reg_sunab_all <- reg_sunab_all[
  (!is.na(cohort) & YEAR >= cohort - 3L & YEAR <= cohort + 3L) |
  (is.na(cohort) & paste(bank_id, county) %in% paste(keep_never$bank_id, keep_never$county))
]
reg_sunab_all[is.na(cohort), cohort := 10000L]
reg_sunab_all[, unit_id := .GRP, by = .(bank_id, county)]

sunab_pre2012 <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1) | unit_id + YEAR,
  data = reg_sunab_all[YEAR < 2012],
  vcov = ~ bank_id
)
sunab_2012_2019 <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1) | unit_id + YEAR,
  data = reg_sunab_all[YEAR >= 2012 & YEAR <= 2019],
  vcov = ~ bank_id
)
sunab_2020_2024 <- feols(
  log1p(total_deps_all_branches) ~ sunab(cohort, YEAR, ref.p = -1) | unit_id + YEAR,
  data = reg_sunab_all[YEAR >= 2020],
  vcov = ~ bank_id
)

# g1 <- ggiplot(sunab_pre2012,
#         main = "Sun & Abraham: Pre 2012 (All Branch Deposits)",
#         xlab = "Years Relative to First Closure",
#         ylab = "log(1 + deposits)")
# 
# g2 <- ggiplot(sunab_2012_2019,
#         main = "Sun & Abraham: 2012-2019 (All Branch Deposits)",
#         xlab = "Years Relative to First Closure",
#         ylab = "log(1 + deposits)")
# 
# g3 <- ggiplot(sunab_2020_2024,
#         main = "Sun & Abraham: 2020-2024 (All Branch Deposits)",
#         xlab = "Years Relative to First Closure",
#         ylab = "log(1 + deposits)")
# 
# grid.arrange(g1,g2,g3,nrow=1)
```

```{r}
# --- Block 13: Superimposed Sun & Abraham (All Branch Deposits), by period (colored) ---

# Helper to extract sunab event-time estimates from a fixest model
sunab_tidy <- function(model, label) {
  ct <- as.data.table(coeftable(model), keep.rownames = "term")
  ct <- ct[grepl("sunab\\(|::", term)]
  if (nrow(ct) == 0) stop("No sunab terms detected. Check that the model includes sunab(cohort, YEAR, ...).")

  ct[, event_time := as.integer(gsub(".*?(-?\\d+)\\D*$", "\\1", term))]
  ct[, `:=`(
    estimate = Estimate,
    se       = `Std. Error`,
    period   = label
  )]
  ct[, .(period, event_time, estimate, se)]
}


add_ref_point <- function(es_dt, ref = -1L) {
  refs <- unique(es_dt[, .(period)])
  refs[, `:=`(event_time = ref, estimate = 0, se = 0)]
  out <- rbindlist(list(es_dt, refs), fill = TRUE)
  setorder(out, period, event_time)
  out
}

es13_all <- add_ref_point(es13_all, ref = -1L)

ggplot(es13_all, aes(x = event_time, y = estimate, group = period, color = period)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  geom_line(linewidth = 0.8) +
  geom_point(aes(shape = period), size = 2.2) +
  geom_errorbar(
    aes(ymin = estimate - 1.96 * se, ymax = estimate + 1.96 * se),
    width = 0.2,
    linewidth = 0.4
  ) +
  scale_color_manual(values = c(
    "Pre 2012"   = "#1b9e77",
    "2012-2019"  = "#d95f02",
    "2020-2024"  = "#7570b3"
  )) +
  labs(
    title = "Sun & Abraham: All Branch Deposits (Superimposed by Period)",
    x = "Years Relative to First Closure",
    y = "Event-time effect (log deposits)",
    color = "Period",
    shape = "Period"
  ) +
  theme_minimal()

```


```{r}
cat("\n=== SUN & ABRAHAM: CONSISTENT BRANCH SET ===\n")

# Cohort (first closure year for treated bank-counties)
first_closure <- bank_cty_yr[any_closure_t == 1L, .(cohort = min(YEAR)), by = .(bank_id, county)]

# Identify branches that close in the cohort year (to exclude from "consistent" series)
branch_status <- closure_app[, .(
  bank_id, county, YEAR, UNINUMBR,
  closes_now = (closed == 1L)
)]

branch_status <- merge(branch_status, first_closure, by = c("bank_id", "county"), all.x = TRUE)
branch_status[, closes_at_cohort := closes_now & YEAR == cohort]

branches_to_exclude <- unique(branch_status[closes_at_cohort == TRUE, .(bank_id, county, UNINUMBR)])
cat("Branches that close at cohort year:", nrow(branches_to_exclude), "\n")

# ---- Correct exclusion: mark-and-filter (fast anti-join) ----
branches_to_exclude[, exclude := TRUE]
closure_app2 <- branches_to_exclude[closure_app, on = .(bank_id, county, UNINUMBR)]
closure_app2 <- closure_app2[is.na(exclude)]
closure_app2[, exclude := NULL]

# Consistent deposits series: all deposits excluding cohort-closing branches
bank_cty_yr_consistent <- closure_app2[, .(
  deps_consistent = sum(DEPSUMBR, na.rm = TRUE),
  n_branches_consistent = uniqueN(UNINUMBR)
), by = .(bank_id, county, YEAR)]

reg_sunab_cons <- merge(bank_cty_yr_consistent, first_closure, by = c("bank_id", "county"), all.x = TRUE)

# Sample never-treated bank-counties
set.seed(123)
never_bc <- unique(reg_sunab_cons[is.na(cohort), .(bank_id, county)])
keep_never <- never_bc[sample(.N, max(1, floor(.N * params$never_treated_share)))]

# Filter: treated in ±3 window OR sampled never-treated (all years)
reg_sunab_cons <- reg_sunab_cons[
  (!is.na(cohort) & YEAR >= cohort - 3L & YEAR <= cohort + 3L) |
  (is.na(cohort) & paste(bank_id, county) %in% paste(keep_never$bank_id, keep_never$county))
]

# Set cohort = 10000 for never-treated and create unit FE id
reg_sunab_cons[is.na(cohort), cohort := 10000L]
reg_sunab_cons[, unit_id := .GRP, by = .(bank_id, county)]

# Run Sun & Abraham by period
sunab_consistent_pre2012 <- feols(
  log1p(deps_consistent) ~ sunab(cohort, YEAR, ref.p = -1) | unit_id + YEAR,
  data = reg_sunab_cons[YEAR < 2012],
  vcov = ~ bank_id
)

sunab_consistent_2012_2019 <- feols(
  log1p(deps_consistent) ~ sunab(cohort, YEAR, ref.p = -1) | unit_id + YEAR,
  data = reg_sunab_cons[YEAR >= 2012 & YEAR <= 2019],
  vcov = ~ bank_id
)

sunab_consistent_2020_2024 <- feols(
  log1p(deps_consistent) ~ sunab(cohort, YEAR, ref.p = -1) | unit_id + YEAR,
  data = reg_sunab_cons[YEAR >= 2020],
  vcov = ~ bank_id
)

# 
# g1 <- ggiplot(sunab_consistent_pre2012,
#         main = "Sun & Abraham (Consistent Set): Pre 2012",
#         xlab = "Years Relative to First Closure",
#         ylab = "log(1 + deposits)")
# 
# g2 <- ggiplot(sunab_consistent_2012_2019,
#         main = "Sun & Abraham (Consistent Set): 2012-2019",
#         xlab = "Years Relative to First Closure",
#         ylab = "log(1 + deposits)")
# 
# g3 <- ggiplot(sunab_consistent_2020_2024,
#         main = "Sun & Abraham (Consistent Set): 2020-2024",
#         xlab = "Years Relative to First Closure",
#         ylab = "log(1 + deposits)")
# 
# grid.arrange(g1,g2,g3,nrow=1)
```
```{r}
# --- Superimposed event-study plot (robust; no ggplot_build scraping) ---

# Extract event-time estimates from a fixest model with sunab()
# sunab_tidy <- function(model, label) {
#   ct <- as.data.table(coeftable(model), keep.rownames = "term")
#   # Keep only sunab event-time terms; fixest names vary but always include "::" for sunab
#   ct <- ct[grepl("sunab\\(|::", term)]
#   if (nrow(ct) == 0) stop("No sunab terms detected. Check that the model includes sunab(cohort, YEAR, ...).")
# 
#   # Parse event time from the term name.
#   # Common patterns include "...::(-3)" or "...::3" etc. We'll grab the last integer in the string.
#   ct[, event_time := as.integer(gsub(".*?(-?\\d+)\\D*$", "\\1", term))]
# 
#   ct[, `:=`(
#     estimate = Estimate,
#     se       = `Std. Error`,
#     period   = label
#   )]
# 
#   ct[, .(period, event_time, estimate, se)]
# }
# 
# add_ref_point <- function(es_dt, ref = -1L) {
#   refs <- unique(es_dt[, .(period)])
#   refs[, `:=`(event_time = ref, estimate = 0, se = 0)]
#   out <- rbindlist(list(es_dt, refs), fill = TRUE)
#   setorder(out, period, event_time)
#   out
# }


es_all <- rbindlist(list(
  sunab_tidy(sunab_consistent_pre2012,  "Pre 2012"),
  sunab_tidy(sunab_consistent_2012_2019,"2012-2019"),
  sunab_tidy(sunab_consistent_2020_2024,"2020-2024")
), fill = TRUE)


es_all <- add_ref_point(es_all, ref = -1L)
# Optional: drop reference period if it accidentally appears (usually -1 is ref and omitted)
# es_all <- es_all[event_time != -1]

# Same superimposed plot, but with explicit colors
ggplot(es_all, aes(x = event_time, y = estimate, group = period, color = period)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  geom_line(linewidth = 0.8) +
  geom_point(aes(shape = period), size = 2.2) +
  geom_errorbar(
    aes(ymin = estimate - 1.96 * se, ymax = estimate + 1.96 * se),
    width = 0.2,
    linewidth = 0.4
  ) +
  scale_color_manual(values = c(
    "Pre 2012"   = "#1b9e77",
    "2012-2019"  = "#d95f02",
    "2020-2024"  = "#7570b3"
  )) +
  labs(
    title = "Sun & Abraham (Consistent Branch Set): Superimposed by Period",
    x = "Years Relative to First Closure",
    y = "Event-time effect",
    color = "Period",
    shape = "Period"
  ) +
  theme_minimal()


```


```{r}
cat("\n=== SUN & ABRAHAM (SAMPLED NEVER-TREATED) ===\n")

# Cohort = first closure year at bank-county
first_closure <- bank_cty_yr[any_closure_t == 1L, .(cohort = min(YEAR)), by = .(bank_id, county)]

reg_sunab <- merge(
  bank_cty_yr[, .(bank_id, county, YEAR, total_deps_bank_county_t1, n_remaining_branches, any_closure_t)],
  first_closure,
  by = c("bank_id", "county"),
  all.x = TRUE
)

# Sample never-treated bank-counties
set.seed(123)
never_bc <- unique(reg_sunab[is.na(cohort), .(bank_id, county)])
keep_never <- never_bc[sample(.N, max(1, floor(.N * params$never_treated_share)))]

reg_sunab <- reg_sunab[
  (!is.na(cohort) & YEAR >= cohort - 3L & YEAR <= cohort + 3L) |
  (is.na(cohort) & paste(bank_id, county) %in% paste(keep_never$bank_id, keep_never$county))
]

reg_sunab[is.na(cohort), cohort := 10000L]
reg_sunab[, unit_id := .GRP, by = .(bank_id, county)]

sunab_model <- feols(
  log1p(n_remaining_branches) ~ sunab(cohort, YEAR, ref.p = -1) | unit_id + YEAR,
  data = reg_sunab,
  vcov = ~ bank_id
)

ggiplot(sunab_model,
        main = "Sun & Abraham: Event Study (sampled never-treated controls)",
        xlab = "Years Relative to First Closure",
        ylab = "log(1 + remaining branches)")

```
